<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ArbitoInator Monitor</title>
  <!-- Modern sans + mono. If Google Fonts is blocked, fallbacks are used. -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #0b0c0f;
      --panel: rgba(18,20,26,0.92);
      --panel-2: rgba(24,26,34,0.90);
      --stroke: rgba(255,255,255,0.08);
      --text: #f5f5f7;
      --muted: #b5b7c2;
      --good: #32d74b;
      --warn: #ff9f0a;
      --bad: #ff453a;
      --blue: #0a84ff;
      --red: #ff453a;
      --shadow: 0 24px 60px rgba(0,0,0,0.45);
      --radius: 20px;

      /* Deals table columns */
      --col-time: 74px;
      --col-route: minmax(220px, 1fr);
      --col-spent: 120px;
      --col-roi: 90px;
      --col-profit: 130px;
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      font-family: "Manrope", "Avenir Next", "Helvetica Neue", sans-serif;
      background:
        radial-gradient(900px 520px at 85% -10%, rgba(10,132,255,0.20), transparent 60%),
        radial-gradient(800px 520px at 10% 110%, rgba(10,132,255,0.12), transparent 62%),
        linear-gradient(180deg, #0b0c0f 0%, #0f1116 100%);
      color: var(--text);
      min-height: 100vh;
    }

    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(600px 320px at 15% 10%, rgba(255,255,255,0.04), transparent 60%),
        radial-gradient(520px 360px at 85% 85%, rgba(255,255,255,0.03), transparent 62%);
      opacity: 0.7;
    }
    body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: linear-gradient(120deg, rgba(255,255,255,0.03), rgba(255,255,255,0.0) 35%, rgba(255,255,255,0.02));
      opacity: 0.4;
      mix-blend-mode: screen;
    }

    .frame{
      max-width: 1280px;
      margin: 24px auto;
      padding: 0 18px 28px;
    }

    .titlebar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 18px;
      padding: 18px 18px 16px;
      border-radius: calc(var(--radius) + 6px);
      background: var(--panel-2);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
    }

    .title{
      font-weight: 700;
      letter-spacing: .01em;
      font-size: clamp(20px, 2.6vw, 36px);
      margin:0;
      line-height:1.15;
    }

    .mono{
      font-family: "IBM Plex Mono", "SF Mono", "Menlo", "Monaco", "Consolas", monospace;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.03);
      color: var(--muted);
      min-width: 280px;
      justify-content: space-between;
    }
    .pill b{ color: var(--text); font-weight: 700; }
    .dot{
      width: 10px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.2);
      box-shadow: 0 0 0 6px rgba(255,255,255,0.04);
    }
    .dot.ok{ background: var(--good); box-shadow: 0 0 0 6px rgba(50,215,75,0.20); }
    .dot.off{ background: rgba(255,255,255,0.22); box-shadow: 0 0 0 6px rgba(255,255,255,0.06); }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr 0.95fr;
      gap: 20px;
      margin-top: 16px;
      align-items: start;
    }

    .card{
      border-radius: var(--radius);
      background: var(--panel);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .cardHeader{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
    }

    .cardHeader h2{
      margin:0;
      font-size: 13px;
      letter-spacing: .02em;
      text-transform: none;
      color: var(--muted);
      font-weight: 600;
    }

    /* Left column becomes an operator stack: logs -> chart -> deals */
    .leftStack{
      display:flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      min-height: 0;
    }

    .logFeed{
      height: 320px;
      overflow:auto;
      padding: 12px 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
    }

    .chartBox{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
      overflow:hidden;
      height: 220px;
    }

    .dealsWrap{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
      overflow:hidden;
      min-height: 0;
      flex: 1;
      display:flex;
      flex-direction: column;
    }

    .tableHead{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .tableHead h3{
      margin:0;
      font-size: 12px;
      letter-spacing: .04em;
      text-transform: none;
      color: var(--muted);
      font-weight: 600;
    }

    .dealsBody{
      overflow:auto;
      min-height: 0;
      padding: 0 8px 10px;
    }

    .logItem{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(12,14,18,0.7);
      margin-bottom: 10px;
    }
    .logItem .meta{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content: space-between;
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 6px;
    }
    .logItem .text{ font-size: 13px; line-height: 1.35; }

    .badge{
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      white-space: nowrap;
    }
    .badge.good{ color: var(--good); border-color: rgba(50,215,75,0.35); background: rgba(50,215,75,0.10);} 
    .badge.warn{ color: var(--warn); border-color: rgba(255,159,10,0.35); background: rgba(255,159,10,0.10);} 
    .badge.bad{ color: var(--bad); border-color: rgba(255,69,58,0.35); background: rgba(255,69,58,0.10);} 
    .badge.blue{ color: var(--blue); border-color: rgba(10,132,255,0.45); background: rgba(10,132,255,0.12);} 

    .rightTop{
      padding: 14px 16px 10px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .kv{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(8,10,14,0.6);
      border: 1px solid rgba(255,255,255,0.06);
    }
    .kv span{ color: var(--muted); font-size: 12px; }
    .kv b{ font-size: 14px; }

    .notice{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(8,10,14,0.6);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .notice .left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .notice .msg{
      color: var(--muted);
      font-size: 13px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .buttons{
      display:flex;
      gap: 12px;
      padding: 10px 16px 14px;
      align-items:center;
      justify-content: center;
    }

    .btn{
      width: 100%;
      border-radius: 999px;
      padding: 12px 16px;
      font-weight: 600;
      letter-spacing: .01em;
      text-transform: none;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, opacity .12s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn:hover{ background: rgba(255,255,255,0.08); }
    .btn.primary{ 
      background: linear-gradient(180deg, rgba(10,132,255,0.30), rgba(10,132,255,0.14));
      border-color: rgba(10,132,255,0.45);
      box-shadow: 0 0 0 1px rgba(10,132,255,0.06), 0 0 22px rgba(10,132,255,0.12);
    } 
    .btn.danger{ 
      background: linear-gradient(180deg, rgba(255,69,58,0.26), rgba(255,69,58,0.12));
      border-color: rgba(255,69,58,0.45);
      box-shadow: 0 0 0 1px rgba(255,69,58,0.06), 0 0 22px rgba(255,69,58,0.12);
    } 
    .btn:disabled{
      opacity: .40;
      cursor: not-allowed;
      transform: none;
    }

    .dashboard{
      padding: 12px 12px 14px;
    }

    .stats{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }
    .stat{
      padding: 12px 12px;
      border-radius: 16px;
      background: rgba(10,12,16,0.7);
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.02);
    }
    .stat .k{ color: rgba(255,255,255,0.70); font-size: 12px; }
    .stat .v{ font-size: 18px; font-weight: 700; margin-top: 4px; }

    .chartWrap{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
      padding: 10px;
      margin-bottom: 10px;
    }

    canvas{ width:100%; height: 210px; display:block; }

    .table{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(10,12,16,0.6);
      overflow: auto;
    }

    /* Profit rows live inside the left operator stack; scrolling is handled by .dealsBody */
    #profitRows{ overflow: visible; max-height: none; }

    .routeDetails{ width: 100%; }
    .routeDetails summary{
      cursor: pointer;
      list-style: none;
      outline: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .routeDetails summary::-webkit-details-marker{ display: none; }
    .routeFull{
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.80);
      font-size: 12px;
      overflow-x: auto;
      white-space: nowrap;
    }
    .row{
      display:grid;
      grid-template-columns: var(--col-time) var(--col-route) var(--col-spent) var(--col-roi) var(--col-profit);
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      align-items:center;
      font-size: 13px;
    }
    .row.header{
      position: sticky;
      top: 0;
      z-index: 1;
      background: rgba(16,18,24,0.92);
      backdrop-filter: blur(6px);
    }
    .row > div{ min-width: 0; }
    .row:last-child{ border-bottom: none; }
    .row .muted{ color: var(--muted); font-size: 12px; }
    .row .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .row.header{
      position: relative;
      user-select: none;
    }
    .row.header .col{
      position: relative;
      padding-right: 10px;
    }
    .colResizer{
      position: absolute;
      top: -6px;
      right: -8px;
      width: 14px;
      height: calc(100% + 12px);
      cursor: col-resize;
      touch-action: none;
      z-index: 2;
    }
    .colResizer::after{
      content:"";
      position: absolute;
      top: 8px;
      bottom: 8px;
      left: 6px;
      width: 1px;
      background: rgba(255,255,255,0.12);
    }

    /* Route cell: long strings should not break the layout */
    .routeCell{ min-width: 0; }
    .routeCell .scroll{
      overflow-x: auto;
      white-space: nowrap;
      padding-bottom: 2px;
      scrollbar-width: thin;
    }
    .routeCell details{ display: inline; }
    .routeCell summary{
      cursor: pointer;
      list-style: none;
      color: rgba(255,255,255,0.88);
    }
    .routeCell summary::-webkit-details-marker{ display:none; }
    .routeCell .full{
      display: block;
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(12,14,18,0.8);
      border: 1px solid rgba(255,255,255,0.06);
      white-space: pre;
      overflow-x: auto;
    }

    #rpcStatsBody{
      overflow-x: auto;
      white-space: nowrap;
      display: block;
      padding-bottom: 2px;
      scrollbar-width: thin;
    }

    /* Settings */
    .settings{
      margin-top: 12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(10,12,16,0.6);
      padding: 12px;
    }
    .settings h3{
      margin: 0 0 10px;
      font-size: 12px;
      letter-spacing: .02em;
      text-transform: none;
      color: var(--muted);
    }
    .settingsGrid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .field{ display:flex; flex-direction:column; gap:6px; }
    .field label{ font-size: 12px; color: var(--muted); }
    .field input,
    .field select,
    .field textarea{
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      padding: 10px 10px;
      outline: none;
      font-size: 13px;
    }
    .field input:focus,
    .field select:focus,
    .field textarea:focus{
      border-color: rgba(10,132,255,0.55);
      box-shadow: 0 0 0 2px rgba(10,132,255,0.15);
    }
    .field small{ color: rgba(255,255,255,0.55); font-size: 11px; }
    .settingsActions{ display:flex; gap: 10px; margin-top: 12px; }

    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .pill{ min-width: auto; width: 100%; }
      .logFeed{ height: 360px; }
      .chartBox{ height: 200px; }
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="titlebar">
      <h1 class="title">ArbitoInator Monitor</h1>
      <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:flex-end;">
        <div class="pill" title="–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –ø—Ä–æ—Ü–µ—Å—Å–∞">
        <div style="display:flex; align-items:center; gap:10px; min-width:0;">
          <div id="connDot" class="dot off"></div>
          <div style="display:flex; flex-direction:column; min-width:0;">
            <span style="font-size:12px; color:var(--muted);">Connection</span>
            <b id="connText" style="font-size:13px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">offline</b>
          </div>
        </div>
        <div class="badge" id="runBadge">stopped</div>
        </div>

        <!-- Uptime timer (requested) -->
        <div class="pill" style="min-width: 190px;" title="–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –ø—Ä–æ—Ü–µ—Å—Å–∞">
          <div style="display:flex; flex-direction:column; min-width:0;">
            <span style="font-size:12px; color:var(--muted);">Uptime</span>
            <b id="uptimeText" class="mono" style="font-size:13px;">00:00:00</b>
          </div>
          <div class="badge blue" id="uptimeState">‚Äî</div>
        </div>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: operator stack (logs -> chart -> deals) -->
      <section class="card" style="min-height:0;">
        <div class="cardHeader">
          <h2>–û–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –ª–µ–Ω—Ç–∞</h2>
          <span class="badge blue" id="logCount">0</span>
        </div>

        <div class="leftStack">
          <div class="logFeed" id="logs" aria-label="Logs"></div>

          <div class="chartBox" title="Profit timeline (–ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è)">
            <canvas id="profitChart" width="900" height="260"></canvas>
          </div>

          <div class="dealsWrap" aria-label="–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø—Ä–æ—Ñ–∏—Ç–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è">
            <div class="tableHead">
              <h3>Deals</h3>
              <span class="badge" id="dealsHint">latest</span>
            </div>
            <div class="table" id="dealsTable" style="margin: 0 8px 8px;">
              <div class="row header" style="background: rgba(255,255,255,0.04); font-weight:800; color: rgba(255,255,255,0.75);">
                <div class="col col-time muted">Time<span class="colResizer" data-col="time"></span></div>
                <div class="col col-route muted">Route<span class="colResizer" data-col="route"></span></div>
                <div class="col col-spent muted" style="text-align:right;">Spent<span class="colResizer" data-col="spent"></span></div>
                <div class="col col-roi muted" style="text-align:right;">ROI<span class="colResizer" data-col="roi"></span></div>
                <div class="col col-profit muted" style="text-align:right;">Profit</div>
              </div>
              <div class="dealsBody" id="profitRows"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT: status + dashboard -->
      <section class="card">
        <div class="rightTop">
          <div class="kv">
            <span>Last scanned Block</span>
            <b class="mono" id="lastBlock">‚Äî</b>
          </div>
          <div class="notice" id="notice">
            <div class="left">
              <span class="badge" id="noticeIcon" aria-hidden="true">‚Ñπ</span>
              <div class="msg" id="noticeText">No data yet. Press Start to begin.</div>
            </div>
            <div class="badge" id="opBadge">idle</div>
          </div>
        </div>

        <div class="dashboard">
          <!-- Stats stay on the right -->
          <div class="stats">
            <div class="stat">
              <div class="k">Blocks scanned</div>
              <div class="v" id="statBlocks">0</div>
            </div>
            <div class="stat">
              <div class="k">Profitable hits</div>
              <div class="v" id="statHits">0</div>
            </div>
            <div class="stat">
              <div class="k">Total profit</div>
              <div class="v" id="statProfit">0.000000</div>
            </div>
            <div class="stat">
              <div class="k">Total spent</div>
              <div class="v" id="statSpent">0.000</div>
            </div>
            <div class="stat">
              <div class="k">Avg ROI</div>
              <div class="v" id="statRoi">0.00%</div>
            </div>
          </div>

          <div class="stats">
            <div class="stat">
              <div class="k">Raw opps</div>
              <div class="v" id="statRaw">0</div>
            </div>
            <div class="stat">
              <div class="k">After slippage+MEV</div>
              <div class="v" id="statSafety">0</div>
            </div>
            <div class="stat">
              <div class="k">After gas/limits</div>
              <div class="v" id="statGas">0</div>
            </div>
            <div class="stat">
              <div class="k">Ready to execute</div>
              <div class="v" id="statReady">0</div>
            </div>
          </div>

          <!-- RPC pool health (updates live) -->
          <div class="stats" style="margin-top:10px;">
            <div class="stat" style="grid-column: 1 / -1;">
              <div class="k">RPC pool</div>
              <div class="v" style="font-size:12px; line-height:1.35; font-weight:600; color:rgba(255,255,255,0.85)">
                <div id="rpcStatsBody" class="mono">‚Äî</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Settings (editable from UI) -->
        <div class="settings" id="settings">
          <h3>Settings</h3>
          <div class="settingsGrid">
            <div class="field" style="grid-column: 1 / -1;">
              <label for="cfgRpcUrls">RPC URLs (parallel pool)</label>
              <textarea id="cfgRpcUrls" rows="3" class="mono" placeholder="https://rpc1\nhttps://rpc2\n..." style="width:100%; resize:vertical;"></textarea>
              <small>One per line (or comma-separated). The bot will spread load across all URLs and retry on failures.</small>
            </div>
            <div class="field" style="grid-column: 1 / -1;">
              <label for="cfgDexes">DEX adapters</label>
              <input id="cfgDexes" type="text" class="mono" placeholder="univ3,univ2,sushiswap" />
              <small>Comma list. Order matters only for display; best quote is chosen per hop.</small>
            </div>
            <div class="field">
              <label for="cfgReportCurrency">Reporting currency</label>
              <select id="cfgReportCurrency">
                <option value="USDC">USDC</option>
                <option value="USDT">USDT</option>
              </select>
              <small>All stats in the panel will be displayed in this currency (bot scans only cycles that start/end in it).</small>
            </div>
            <div class="field">
              <label for="cfgMinPct">Min profit % (of input)</label>
              <input id="cfgMinPct" type="number" step="0.01" min="0" />
              <small>e.g. 0.05 = 0.05%</small>
            </div>
            <div class="field">
              <label for="cfgMinAbs">Min profit absolute</label>
              <input id="cfgMinAbs" type="number" step="0.001" min="0" />
              <small>in base token units (USDC/USDT/DAI)</small>
            </div>
            <div class="field">
              <label for="cfgSlip">Slippage safety (bps)</label>
              <input id="cfgSlip" type="number" step="1" min="0" />
              <small>5 = 0.05%</small>
            </div>
            <div class="field">
              <label for="cfgMev">MEV buffer (bps)</label>
              <input id="cfgMev" type="number" step="1" min="0" />
              <small>extra safety margin on top of slippage</small>
            </div>
            <div class="field">
              <label for="cfgGas">Max gas (gwei)</label>
              <input id="cfgGas" type="number" step="1" min="0" placeholder="(no limit)" />
              <small>empty = don't skip blocks</small>
            </div>
            <div class="field">
              <label for="cfgConc">Concurrency</label>
              <input id="cfgConc" type="number" step="1" min="1" max="200" />
              <small>RPC parallel quotes (25-50 typical)</small>
            </div>
            <div class="field">
              <label for="cfgMode">Scan mode</label>
              <select id="cfgMode">
                <option value="auto">auto (Stage1 + Stage2 optimize)</option>
                <option value="fixed">fixed (preset amounts)</option>
              </select>
              <small>auto = fast + smart; fixed = brute force</small>
            </div>
            <div class="field">
              <label for="cfgBudget">Block budget (sec)</label>
              <input id="cfgBudget" type="number" step="0.5" min="1" />
              <small>hard limit per block (prevents hanging)</small>
            </div>
            <div class="field">
              <label for="cfgAmts">Amounts (comma list)</label>
              <input id="cfgAmts" type="text" placeholder="1,3,10" />
              <small>token_in units; increases search coverage</small>
            </div>
            <div class="field">
              <label for="cfgS1Amt">Stage1 amount</label>
              <input id="cfgS1Amt" type="number" step="0.1" min="0" />
              <small>cheap filter amount</small>
            </div>
            <div class="field">
              <label for="cfgTopK">Stage2 top-K</label>
              <input id="cfgTopK" type="number" step="1" min="1" max="500" />
              <small>how many routes get optimized</small>
            </div>
            <div class="field">
              <label for="cfgRange">Stage2 amount range</label>
              <input id="cfgRange" type="text" placeholder="0.5..50" />
              <small>min..max (units of token_in)</small>
            </div>
            <div class="field">
              <label for="cfgEvals">Stage2 max evals</label>
              <input id="cfgEvals" type="number" step="1" min="2" max="12" />
              <small>RPC calls per route for optimization</small>
            </div>
            <div class="field">
              <label for="cfgT1">RPC timeout Stage1 (sec)</label>
              <input id="cfgT1" type="number" step="0.5" min="1" />
              <small>short timeout keeps block moving</small>
            </div>
            <div class="field">
              <label for="cfgT2">RPC timeout Stage2 (sec)</label>
              <input id="cfgT2" type="number" step="0.5" min="1" />
              <small>longer timeout to not miss profit</small>
            </div>
            <div class="field">
              <label for="cfgV2Ratio">V2 min reserve ratio</label>
              <input id="cfgV2Ratio" type="number" step="1" min="0" />
              <small>reserve_in >= amount_in * ratio</small>
            </div>
            <div class="field">
              <label for="cfgV2Impact">V2 max price impact (bps)</label>
              <input id="cfgV2Impact" type="number" step="1" min="0" />
              <small>drop quotes with high impact</small>
            </div>
          </div>
          <div class="settingsActions">
            <button id="saveCfgBtn" class="btn">save</button>
            <button id="applyCfgBtn" class="btn primary">apply & restart</button>
          </div>
        </div>

        <div class="buttons">
          <button id="startBtn" class="btn primary" disabled>start</button>
          <button id="stopBtn" class="btn danger" disabled>stop</button>
        </div>

        <div style="padding: 0 16px 16px;">
          <div class="kv" style="margin-top: -6px;">
            <span>–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã</span>
            <b id="stateText" class="mono">stopped</b>
          </div>
        </div>
      </section>
    </div>
  </div>

<script>
  // -----------------------------
  // State
  const logsDiv = document.getElementById('logs');
  const logCount = document.getElementById('logCount');

  const connDot = document.getElementById('connDot');
  const connText = document.getElementById('connText');
  const runBadge = document.getElementById('runBadge');
  const stateText = document.getElementById('stateText');

  // Uptime
  const uptimeText = document.getElementById('uptimeText');
  const uptimeState = document.getElementById('uptimeState');
  let botStartedAtMs = null; // set from server (started_at_ms)

  const lastBlockEl = document.getElementById('lastBlock');
  const noticeIcon = document.getElementById('noticeIcon');
  const noticeText = document.getElementById('noticeText');
  const opBadge = document.getElementById('opBadge');

  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');

  const statBlocks = document.getElementById('statBlocks');
  const statHits = document.getElementById('statHits');
  const statProfit = document.getElementById('statProfit');
  const statSpent = document.getElementById('statSpent');
  const statRoi = document.getElementById('statRoi');
  const statRaw = document.getElementById('statRaw');
  const statSafety = document.getElementById('statSafety');
  const statGas = document.getElementById('statGas');
  const statReady = document.getElementById('statReady');
  const rpcStatsBody = document.getElementById('rpcStatsBody');

  const profitRows = document.getElementById('profitRows');
  const canvas = document.getElementById('profitChart');
  const ctx = canvas.getContext('2d');

  const STORAGE_KEY = 'arbito_ui_state_v2';
  const MAX_LOGS = 120;
  const MAX_PROFITS = 200;
  let saveTimer = null;
  let lastSavedAtMs = 0;

  let logs = 0;
  let blocksScanned = 0;
  let lastCountedBlock = null;
  let profitableHits = 0;
  let rawOpps = 0;
  let safetyOpps = 0;
  let gasOpps = 0;
  let readyOpps = 0;
  const totalProfitBySym = {}; // {USDC: 1.23, USDT: 0.10, ...}
  const totalSpentBySym = {};  // {USDC: 10.0, USDT: 5.0, ...}
  let profitCurrency = 'USDC'; // currently displayed currency
  const logItems = [];
  const profitEvents = []; // {t, block, profit, route, sym}

  // Settings elements
  const cfgRpcUrls = document.getElementById('cfgRpcUrls');
  const cfgDexes = document.getElementById('cfgDexes');
  const cfgReportCurrency = document.getElementById('cfgReportCurrency');
  const cfgMinPct = document.getElementById('cfgMinPct');
  const cfgMinAbs = document.getElementById('cfgMinAbs');
  const cfgSlip = document.getElementById('cfgSlip');
  const cfgMev = document.getElementById('cfgMev');
  const cfgGas = document.getElementById('cfgGas');
  const cfgConc = document.getElementById('cfgConc');
  const cfgMode = document.getElementById('cfgMode');
  const cfgBudget = document.getElementById('cfgBudget');
  const cfgAmts = document.getElementById('cfgAmts');
  const cfgS1Amt = document.getElementById('cfgS1Amt');
  const cfgTopK = document.getElementById('cfgTopK');
  const cfgRange = document.getElementById('cfgRange');
  const cfgEvals = document.getElementById('cfgEvals');
  const cfgT1 = document.getElementById('cfgT1');
  const cfgT2 = document.getElementById('cfgT2');
  const cfgV2Ratio = document.getElementById('cfgV2Ratio');
  const cfgV2Impact = document.getElementById('cfgV2Impact');
  const saveCfgBtn = document.getElementById('saveCfgBtn');
  const applyCfgBtn = document.getElementById('applyCfgBtn');
  const dealsTable = document.getElementById('dealsTable');

  // -----------------------------
  // Formatting helpers (avoid scientific notation in UI)
  function fmtAmount(value, decimals = 3){
    const n = Number(value);
    if (!Number.isFinite(n)) return '‚Äî';
    // If something explodes upstream (overflow), hide it.
    if (Math.abs(n) > 1e12) return '‚Äî';
    return n.toFixed(decimals);
  }

  function fmtPct(value, decimals = 2){
    const n = Number(value);
    if (!Number.isFinite(n)) return '‚Äî';
    // Our bot uses "0.05" to mean 0.05% (same as UI hint).
    return n.toFixed(decimals) + '%';
  }

  // Number formatting helpers (avoid scientific notation in UI)
  function formatToken(x, decimals = 3, maxAbs = 1e12){
    const num = Number(x);
    if (!Number.isFinite(num)) return '‚Äî';
    const ax = Math.abs(num);
    // For very large numbers, show exponential (rounded) instead of "‚àû" or "‚Äî".
    if (ax >= 1e6 && ax <= maxAbs) {
      try { return num.toExponential(2); } catch { return String(num); }
    }
    if (ax > maxAbs) return '>1e12';
    // Intl formatter avoids scientific notation for normal ranges
    try {
      return new Intl.NumberFormat('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      }).format(num);
    } catch {
      return num.toFixed(decimals);
    }
  }

  function formatPct(x, decimals = 2){
    const num = Number(x);
    if (!Number.isFinite(num)) return '‚Äî';
    const ax = Math.abs(num);
    if (ax >= 1e5 && ax <= 1e6) {
      try { return num.toExponential(2) + '%'; } catch { return String(num) + '%'; }
    }
    if (ax > 1e6) return '>1e6%';
    try {
      return new Intl.NumberFormat('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      }).format(num) + '%';
    } catch {
      return num.toFixed(decimals) + '%';
    }
  }

  function currentTotalProfit(){
    return Number(totalProfitBySym[profitCurrency] || 0);
  }

  function setRunning(running){
    runBadge.textContent = running ? 'running' : 'stopped';
    runBadge.className = 'badge ' + (running ? 'good' : '');
    stateText.textContent = running ? 'running' : 'stopped';

    // Button logic you described:
    // - initial start disabled until connected
    // - when running: start disabled, stop enabled
    // - when stopped: start enabled, stop disabled
    if (running){
      startBtn.disabled = true;
      stopBtn.disabled = false;
      if (botStartedAtMs === null) botStartedAtMs = Date.now();
    } else {
      startBtn.disabled = !wsConnected;
      stopBtn.disabled = true;
      botStartedAtMs = null;
    }

    if (uptimeState) {
      uptimeState.textContent = running ? 'running' : 'stopped';
      uptimeState.className = 'badge ' + (running ? 'good' : '');
    }
  }

  function formatUptime(ms){
    const total = Math.max(0, Math.floor(ms / 1000));
    const hh = String(Math.floor(total / 3600)).padStart(2, '0');
    const mm = String(Math.floor((total % 3600) / 60)).padStart(2, '0');
    const ss = String(total % 60).padStart(2, '0');
    return `${hh}:${mm}:${ss}`;
  }

  // Update uptime ticker (top-right)
  setInterval(() => {
    if (!uptimeText) return;
    if (botStartedAtMs == null){
      uptimeText.textContent = '00:00:00';
      return;
    }
    uptimeText.textContent = formatUptime(Date.now() - Number(botStartedAtMs));
  }, 1000);

  function schedulePersist(){
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(persistState, 400);
  }

  function sendStateToServer(state){
    try {
      fetch('/ui_state', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ state: state || {} }),
      }).catch(()=>{});
    } catch (e) {
      // ignore server sync failures
    }
  }

  function persistState(){
    try {
      const savedAtMs = Date.now();
      const state = {
        v: 3,
        saved_at_ms: savedAtMs,
        logs: logItems.slice(-MAX_LOGS),
        profitEvents: profitEvents.slice(-MAX_PROFITS),
        blocksScanned: blocksScanned,
        lastCountedBlock: lastCountedBlock,
        profitableHits: profitableHits,
        rawOpps: rawOpps,
        safetyOpps: safetyOpps,
        gasOpps: gasOpps,
        readyOpps: readyOpps,
        profitCurrency: profitCurrency,
        totalProfitBySym: { ...totalProfitBySym },
        totalSpentBySym: { ...totalSpentBySym },
        lastBlock: lastBlockEl ? lastBlockEl.textContent : null,
        notice: {
          kind: opBadge ? opBadge.textContent : '',
          text: noticeText ? noticeText.textContent : '',
        },
      };
      lastSavedAtMs = savedAtMs;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      sendStateToServer(state);
    } catch (e) {
      // ignore storage failures
    }
  }

  function clearObject(obj){
    Object.keys(obj).forEach((k) => { delete obj[k]; });
  }

  function normalizeProfitEvent(evt){
    if (!evt || typeof evt !== 'object') return null;
    const profit = (evt.profit != null && Number.isFinite(Number(evt.profit))) ? Number(evt.profit) : null;
    const spent = (evt.spent != null && Number.isFinite(Number(evt.spent))) ? Number(evt.spent) : null;
    const roi = (evt.roi_pct != null && Number.isFinite(Number(evt.roi_pct))) ? Number(evt.roi_pct) : null;
    return {
      t: (evt.t != null) ? String(evt.t) : '',
      block: (typeof evt.block === 'number') ? evt.block : null,
      profit: profit,
      sym: (typeof evt.sym === 'string') ? evt.sym.toUpperCase() : null,
      route: (typeof evt.route === 'string') ? evt.route : (typeof evt.route_full === 'string') ? evt.route_full : '‚Äî',
      spent: spent,
      spent_sym: (typeof evt.spent_sym === 'string') ? evt.spent_sym.toUpperCase() : (typeof evt.token_in_sym === 'string') ? evt.token_in_sym.toUpperCase() : null,
      roi_pct: roi,
      route_short: (typeof evt.route_short === 'string') ? evt.route_short : null,
      route_full: (typeof evt.route_full === 'string') ? evt.route_full : null,
    };
  }

  function computeTotalsFromEvents(){
    const profitBySym = {};
    const spentBySym = {};
    let hits = 0;
    profitEvents.forEach((evt) => {
      if (!evt || typeof evt !== 'object') return;
      const sym = String(evt.sym || profitCurrency || 'USDC').toUpperCase();
      if (evt.profit != null && Number.isFinite(Number(evt.profit))){
        profitBySym[sym] = Number(profitBySym[sym] || 0) + Number(evt.profit);
        hits += 1;
      }
      if (evt.spent != null && Number.isFinite(Number(evt.spent))){
        spentBySym[sym] = Number(spentBySym[sym] || 0) + Number(evt.spent);
      }
    });
    return { profitBySym, spentBySym, hits };
  }

  function rebuildTotalsFromEvents(){
    const totals = computeTotalsFromEvents();
    clearObject(totalProfitBySym);
    clearObject(totalSpentBySym);
    Object.assign(totalProfitBySym, totals.profitBySym);
    Object.assign(totalSpentBySym, totals.spentBySym);
    profitableHits = totals.hits;
  }

  function rebuildProfitTable(){
    if (!profitRows) return;
    profitRows.textContent = '';
    const list = profitEvents.slice(-10);
    for (let i = list.length - 1; i >= 0; i--){
      const row = renderProfitRow(list[i]);
      if (row) profitRows.appendChild(row);
    }
  }

  function restoreStateFromData(state){
    if (!state || typeof state !== 'object') return false;
    const savedAt = (typeof state.saved_at_ms === 'number') ? state.saved_at_ms : 0;
    if (lastSavedAtMs && savedAt === 0) return false;
    if (savedAt && savedAt < lastSavedAtMs) return false;
    if (savedAt) lastSavedAtMs = savedAt;

    if (Array.isArray(state.logs)){
      logItems.length = 0;
      if (logsDiv) logsDiv.textContent = '';
      state.logs.slice(-MAX_LOGS).forEach((entry) => {
        const e = {
          type: (entry && typeof entry.type === 'string') ? entry.type : 'log',
          time: (entry && entry.time != null) ? String(entry.time) : '',
          block: (entry && typeof entry.block === 'number') ? entry.block : null,
          text: (entry && entry.text != null) ? String(entry.text) : '',
        };
        logItems.push(e);
        renderLogEntry(e);
      });
      logs = logItems.length;
      if (logCount) logCount.textContent = String(logs);
    }

    if (typeof state.blocksScanned === 'number' && Number.isFinite(state.blocksScanned)){
      blocksScanned = state.blocksScanned;
    }
    if (state.lastCountedBlock !== undefined && state.lastCountedBlock !== null){
      const lb = Number(state.lastCountedBlock);
      if (Number.isFinite(lb)) lastCountedBlock = lb;
    }
    if (typeof state.rawOpps === 'number' && Number.isFinite(state.rawOpps)){
      rawOpps = state.rawOpps;
    }
    if (typeof state.safetyOpps === 'number' && Number.isFinite(state.safetyOpps)){
      safetyOpps = state.safetyOpps;
    }
    if (typeof state.gasOpps === 'number' && Number.isFinite(state.gasOpps)){
      gasOpps = state.gasOpps;
    }
    if (typeof state.readyOpps === 'number' && Number.isFinite(state.readyOpps)){
      readyOpps = state.readyOpps;
    }

    if (typeof state.profitCurrency === 'string' && state.profitCurrency.trim()){
      profitCurrency = state.profitCurrency.trim().toUpperCase();
    }

    if (lastBlockEl && state.lastBlock != null){
      lastBlockEl.textContent = String(state.lastBlock);
      if (lastCountedBlock === null || lastCountedBlock === undefined){
        const lb = Number(state.lastBlock);
        if (Number.isFinite(lb)) lastCountedBlock = lb;
      }
    }

    if (state.notice && typeof state.notice === 'object'){
      const kind = (typeof state.notice.kind === 'string') ? state.notice.kind : 'status';
      const text = (typeof state.notice.text === 'string') ? state.notice.text : '';
      setNotice(kind, text);
    }

    if (Array.isArray(state.profitEvents)){
      profitEvents.length = 0;
      state.profitEvents.slice(-MAX_PROFITS).forEach((evt) => {
        const norm = normalizeProfitEvent(evt);
        if (norm) profitEvents.push(norm);
      });
    }

    const hasProfitTotals = (state.totalProfitBySym && typeof state.totalProfitBySym === 'object');
    const hasSpentTotals = (state.totalSpentBySym && typeof state.totalSpentBySym === 'object');
    if (hasProfitTotals){
      clearObject(totalProfitBySym);
      Object.entries(state.totalProfitBySym).forEach(([k, v]) => {
        const n = Number(v);
        if (Number.isFinite(n)) totalProfitBySym[String(k).toUpperCase()] = n;
      });
    }
    if (hasSpentTotals){
      clearObject(totalSpentBySym);
      Object.entries(state.totalSpentBySym).forEach(([k, v]) => {
        const n = Number(v);
        if (Number.isFinite(n)) totalSpentBySym[String(k).toUpperCase()] = n;
      });
    }

    if (typeof state.profitableHits === 'number' && Number.isFinite(state.profitableHits)){
      profitableHits = state.profitableHits;
    } else if (!hasProfitTotals && !hasSpentTotals) {
      rebuildTotalsFromEvents();
    } else if (!hasProfitTotals || !hasSpentTotals) {
      const totals = computeTotalsFromEvents();
      if (!hasProfitTotals){
        clearObject(totalProfitBySym);
        Object.assign(totalProfitBySym, totals.profitBySym);
      }
      if (!hasSpentTotals){
        clearObject(totalSpentBySym);
        Object.assign(totalSpentBySym, totals.spentBySym);
      }
      if (!Number.isFinite(state.profitableHits)) profitableHits = totals.hits;
    }

    rebuildProfitTable();
    drawChart();
    updateStats();
    return true;
  }

  function restoreState(){
    let raw = null;
    try { raw = localStorage.getItem(STORAGE_KEY); } catch { return false; }
    if (!raw) return false;
    let state;
    try { state = JSON.parse(raw); } catch { return false; }
    return restoreStateFromData(state);
  }

  function fetchServerState(){
    fetch('/ui_state')
      .then((r) => r.json())
      .then((out) => {
        if (out && out.ok && out.state) restoreStateFromData(out.state);
      })
      .catch(()=>{});
  }

  function renderLogEntry({type, time, block, text}){

    const item = document.createElement('div');
    item.className = 'logItem';

    const badge = document.createElement('span');
    badge.className = 'badge';
    if (type === 'profit') badge.classList.add('good');
    if (type === 'warn' || type === 'stderr') badge.classList.add('warn');
    if (type === 'status') badge.classList.add('blue');

    badge.textContent = type || 'log';

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.appendChild(Object.assign(document.createElement('span'), {textContent: time || ''}));

    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.gap = '8px';
    right.style.alignItems = 'center';
    if (typeof block === 'number'){
      const b = document.createElement('span');
      b.className = 'badge blue';
      b.textContent = 'Block ' + block;
      right.appendChild(b);
    }
    right.appendChild(badge);
    meta.appendChild(right);

    const body = document.createElement('div');
    body.className = 'text';
    body.textContent = text || '';

    item.appendChild(meta);
    item.appendChild(body);

    // If user is already near the bottom, keep auto-scrolling like a terminal.
    const nearBottom = (logsDiv.scrollTop + logsDiv.clientHeight) >= (logsDiv.scrollHeight - 40);

    // Newest logs go to the bottom (terminal-style)
    logsDiv.appendChild(item);

    // Keep feed lightweight (remove oldest from the top)
    while (logsDiv.children.length > MAX_LOGS){
      logsDiv.removeChild(logsDiv.firstChild);
    }

    if (nearBottom){
      logsDiv.scrollTop = logsDiv.scrollHeight;
    }
  }

  function addLog({type, time, block, text}){
    const entry = { type: type || 'log', time: time || '', block: block ?? null, text: text || '' };
    logItems.push(entry);
    if (logItems.length > MAX_LOGS) logItems.shift();
    renderLogEntry(entry);
    while (logsDiv.children.length > MAX_LOGS){
      logsDiv.removeChild(logsDiv.firstChild);
    }
    logs = logItems.length;
    logCount.textContent = String(logs);
    schedulePersist();
  }

  function setNotice(kind, msg){
    noticeText.textContent = msg;
    opBadge.textContent = kind;
    opBadge.className = 'badge ' + (kind === 'profit' ? 'good' : kind === 'warn' ? 'warn' : '');

    // Icon + subtle color cue
    if (noticeIcon){
      if (kind === 'profit') noticeIcon.textContent = '‚úÖ';
      else if (kind === 'scan') noticeIcon.textContent = 'üîç';
      else if (kind === 'warn') noticeIcon.textContent = '‚ö†';
      else noticeIcon.textContent = '‚Ñπ';
      noticeIcon.className = 'badge ' + (kind === 'profit' ? 'good' : kind === 'warn' ? 'warn' : kind === 'scan' ? 'blue' : '');
    }

    schedulePersist();
  }

  function updateStats(){
    statBlocks.textContent = String(blocksScanned);
    statHits.textContent = String(profitableHits);
    const sym = profitCurrency || 'USDC';
    let v = Number(totalProfitBySym[sym] || 0);
    if (!Number.isFinite(v) || Math.abs(v) > 1e6) v = 0;
    statProfit.textContent = formatToken(v, 3) + ' ' + sym;

    let spent = Number(totalSpentBySym[sym] || 0);
    if (!Number.isFinite(spent) || Math.abs(spent) > 1e8) spent = 0;
    if (statSpent) statSpent.textContent = formatToken(spent, 3) + ' ' + sym;

    // Avg ROI across successful hits in the currently shown currency
    const roi = (spent > 0) ? (v / spent) * 100 : null;
    if (statRoi) statRoi.textContent = (roi == null || !Number.isFinite(roi) || Math.abs(roi) > 1e6) ? '‚Äî' : formatPct(roi, 2);

    const fmtOpp = (count) => {
      const c = Number(count || 0);
      if (!Number.isFinite(c)) return '0';
      if (blocksScanned > 0) {
        const per = c / blocksScanned;
        return `${Math.round(c)} (${per.toFixed(3)}/blk)`;
      }
      return String(Math.round(c));
    };
    if (statRaw) statRaw.textContent = fmtOpp(rawOpps);
    if (statSafety) statSafety.textContent = fmtOpp(safetyOpps);
    if (statGas) statGas.textContent = fmtOpp(gasOpps);
    if (statReady) statReady.textContent = fmtOpp(readyOpps);
  }

  function parseProfitText(text){
    // fallback parser (older bot versions)
    const mProfit = text.match(/profit\s*=\s*([0-9.+-eE]+)/i);
    const mSpent = text.match(/(?:amount_in|spent|input)\s*=\s*([0-9.+-eE]+)/i);
    const mPct = text.match(/(?:profit_pct|roi|pct)\s*=\s*([0-9.+-eE]+)/i);
    const mSym = text.match(/(?:symbol|token|base)\s*=\s*([A-Z]{3,6})/);
    const mRoute = text.match(/route\s*=\s*(.+?)(?:\s+gas=|$)/i);
    const profit = mProfit ? Number(mProfit[1]) : null;
    const spent = mSpent ? Number(mSpent[1]) : null;
    const profit_pct = mPct ? Number(mPct[1]) : null;
    const route = mRoute ? String(mRoute[1]).trim() : '‚Äî';
    const sym = mSym ? String(mSym[1]) : null;
    return { profit, spent, profit_pct, sym, route };
  }

  function renderProfitRow(evt){
    if (!evt) return null;
    const row = document.createElement('div');
    row.className = 'row';

    const c1 = document.createElement('div');
    c1.className = 'mono';
    c1.textContent = evt.t || '';

    const c2 = document.createElement('div');
    c2.className = 'routeCell';
    const sc = document.createElement('div');
    sc.className = 'scroll mono';

    // Collapsible route (summary stays compact; full route available on demand)
    const det = document.createElement('details');
    const sum = document.createElement('summary');
    sum.textContent = summarizeRoute(evt.route || '‚Äî');
    const full = document.createElement('div');
    full.className = 'full mono';
    full.textContent = evt.route || '‚Äî';
    det.appendChild(sum);
    det.appendChild(full);
    sc.appendChild(det);

    // Allow horizontal scroll with mouse wheel when route overflows
    sc.addEventListener('wheel', (e) => {
      if (sc.scrollWidth > sc.clientWidth){
        sc.scrollLeft += e.deltaY;
        e.preventDefault();
      }
    }, { passive: false });

    c2.appendChild(sc);

    const c3 = document.createElement('div');
    c3.className = 'mono';
    c3.style.textAlign = 'right';
    const spentSym = evt.spent_sym || evt.token_in_sym || 'USDT';
    c3.textContent = (evt.spent == null) ? '‚Äî' : (formatToken(evt.spent, 3) + ' ' + spentSym);

    const c4 = document.createElement('div');
    c4.className = 'mono';
    c4.style.textAlign = 'right';
    c4.textContent = (evt.roi_pct == null) ? '‚Äî' : formatPct(evt.roi_pct, 2);

    const c5 = document.createElement('div');
    c5.className = 'mono';
    c5.style.textAlign = 'right';
    c5.textContent = formatToken(evt.profit || 0, 3) + ' ' + (evt.sym || profitCurrency);

    row.appendChild(c1);
    row.appendChild(c2);
    row.appendChild(c3);
    row.appendChild(c4);
    row.appendChild(c5);
    return row;
  }

  function pushProfitRow(evt){
    if (!profitRows) return;
    const row = renderProfitRow(evt);
    if (!row) return;
    // newest at top
    profitRows.prepend(row);
    while (profitRows.children.length > 10){
      profitRows.removeChild(profitRows.lastChild);
    }
  }

  function summarizeRoute(route){
    const r = String(route || '');
    if (r.length <= 42) return r;
    return r.slice(0, 24) + '‚Ä¶' + r.slice(-14);
  }

  function drawChart(){
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0,0,w,h);

    // axes background grid
    ctx.globalAlpha = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    for (let i=1;i<=4;i++){
      const y = Math.round((h*i)/5);
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(w,y);
      ctx.stroke();
    }

    const data = profitEvents.filter(e => (e.sym || profitCurrency) === profitCurrency).slice(-30);
    if (data.length === 0){
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.font = '700 14px ui-sans-serif, system-ui';
      ctx.fillText('Profit timeline will appear here after first hit', 16, 28);
      return;
    }

    const maxP = Math.max(...data.map(d=>d.profit), 1e-9);
    const minP = 0;

    const padX = 14;
    const padY = 18;

    const xStep = (w - padX*2) / Math.max(1, data.length-1);

    // line
    ctx.strokeStyle = 'rgba(68,194,119,0.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
      const x = padX + i*xStep;
      const y = h - padY - ((d.profit - minP) / (maxP - minP || 1)) * (h - padY*2);
      if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // points
    ctx.fillStyle = 'rgba(68,194,119,0.95)';
    data.forEach((d, i)=>{
      const x = padX + i*xStep;
      const y = h - padY - ((d.profit - minP) / (maxP - minP || 1)) * (h - padY*2);
      ctx.beginPath();
      ctx.arc(x,y,3.3,0,Math.PI*2);
      ctx.fill();
    });

    // label max
    ctx.fillStyle = 'rgba(255,255,255,0.70)';
    ctx.font = '700 12px ui-monospace, monospace';
	    ctx.fillText('max ' + formatToken(maxP, 3) + ' ' + (profitCurrency || ''), 16, h-10);
  }

  // -----------------------------
  // WebSocket
  let ws = null;
  let wsConnected = false;

  function setConn(state){
    wsConnected = state;
    connDot.className = 'dot ' + (state ? 'ok' : 'off');
    connText.textContent = state ? 'online' : 'offline';

    // enable start only when connected AND not running
    if (!state){
      startBtn.disabled = true;
      stopBtn.disabled = true;
    } else {
      // sync status from server
      fetch('/status').then(r=>r.json()).then(s=>{
        if (s && s.ok) {
          if (typeof s.started_at_ms === 'number') botStartedAtMs = s.started_at_ms;
          setRunning(!!s.running);
        }
        else setRunning(false);
      }).catch(()=>setRunning(false));
    }
  }

  function connectWS(){
    ws = new WebSocket(`ws://${location.host}`);

    ws.onopen = () => {
      setConn(true);
      addLog({type:'status', time: new Date().toISOString().slice(11,19), block:null, text:'UI connected'});
    };

    ws.onmessage = (event) => {
      let msg;
      try { msg = JSON.parse(event.data); } catch { return; }

      // unified log
      addLog(msg);

      // Reset runtime UI state (sent by UI server on /restart) to avoid showing stale RPC pool
      if (msg.type === 'reset') {
        blocksScanned = 0;
        lastCountedBlock = null;
        profitableHits = 0;
        rawOpps = 0;
        safetyOpps = 0;
        gasOpps = 0;
        readyOpps = 0;
        clearObject(totalProfitBySym);
        clearObject(totalSpentBySym);
        profitEvents.length = 0;
        if (profitRows) profitRows.textContent = '';
        if (rpcStatsBody) rpcStatsBody.textContent = '‚Äî';
        drawChart();
        updateStats();
        setNotice('status', msg.text || 'restarting...');
        return;
      }

      if (msg.type === 'status'){
        if (typeof msg.started_at_ms === 'number') botStartedAtMs = msg.started_at_ms;
        if (msg.started_at_ms === null) botStartedAtMs = null;
        if (typeof msg.running === 'boolean') setRunning(msg.running);
        if (typeof msg.text === 'string' && msg.text.toLowerCase().includes('stopped')) setRunning(false);
        if (typeof msg.text === 'string' && msg.text.toLowerCase().includes('started')) setRunning(true);
        // Status is for process/network state, not for scan results
        setNotice('status', msg.text || 'status');
      }

      if (msg.type === 'scan'){
        if (typeof msg.block === 'number'){
          lastBlockEl.textContent = String(msg.block);
          const isResult = (
            typeof msg.raw_opps === 'number' ||
            typeof msg.candidates === 'number' ||
            typeof msg.profitable === 'number' ||
            typeof msg.best_profit === 'number'
          );
          if (isResult && msg.block !== lastCountedBlock){
            blocksScanned += 1;
            lastCountedBlock = msg.block;
          }
          if (typeof msg.raw_opps === 'number') rawOpps += msg.raw_opps;
          if (typeof msg.safety_opps === 'number') safetyOpps += msg.safety_opps;
          if (typeof msg.gas_opps === 'number') gasOpps += msg.gas_opps;
          if (typeof msg.final_opps === 'number') readyOpps += msg.final_opps;
          updateStats();
          const candidates = (typeof msg.candidates === 'number') ? msg.candidates : null;
          const profitable = (typeof msg.profitable === 'number') ? msg.profitable : null;
          const best = (typeof msg.best_profit === 'number') ? msg.best_profit : null;

          let summary = msg.text || '';
          if (!summary){
            summary = 'Scan complete';
            if (candidates != null) summary += ` | routes=${candidates}`;
            if (profitable != null) summary += ` | profitable=${profitable}`;
            if (best != null) summary += ` | best=${best.toFixed(6)}`;
          }
          setNotice('scan', summary);
        }
      }

      if (msg.type === 'warn'){
        if (typeof msg.block === 'number') lastBlockEl.textContent = String(msg.block);
        setNotice('warn', msg.text || 'warning');
      }

      if (msg.type === 'rpc_stats'){
        if (rpcStatsBody && Array.isArray(msg.stats)){
          // Render compact: url host | ok/fail | inflight | latency
          const lines = msg.stats.map((s) => {
            const url = String(s.url || '');
            let host = url;
            try { host = (new URL(url)).host; } catch {}
            const ok = Number(s.ok || 0);
            const fail = Number(s.fail || 0);
            const inflight = Number(s.inflight || 0);
            const lat = (typeof s.lat_ms === 'number') ? s.lat_ms : Number(s.lat_ms || 0);
            const weight = (typeof s.weight === 'number') ? s.weight : Number(s.weight || 0);
            const cb = s.cb_open ? 'cb=on' : 'cb=off';
            const fb = s.fallback_only ? 'fb=1' : 'fb=0';
            return `${host.padEnd(24, ' ')} w=${weight} ${fb} ${cb} ok=${ok} fail=${fail} in=${inflight} lat=${lat}ms`;
          });
          rpcStatsBody.textContent = lines.join('\n') || '‚Äî';
        }
      }

      if (msg.type === 'profit'){
        if (typeof msg.block === 'number') lastBlockEl.textContent = String(msg.block);
        // Prefer structured fields from the bot; fall back to parsing text.
        const parsed = parseProfitText(msg.text || '');
        const profit = (typeof msg.profit === 'number') ? msg.profit : parsed.profit;
        const route = (typeof msg.route === 'string') ? msg.route : parsed.route;
        const symFromMsg = (typeof msg.profit_symbol === 'string') ? msg.profit_symbol : (parsed.sym || null);
        // Optional extra fields (newer bot builds may send these)
        const spent = (typeof msg.spent === 'number') ? msg.spent
          : (typeof msg.amount_in_display === 'number') ? msg.amount_in_display
          : (typeof msg.amount_in === 'number') ? msg.amount_in
          : parsed.spent;
        const spentSym = (typeof msg.spent_symbol === 'string') ? msg.spent_symbol
          : (typeof msg.token_in_symbol === 'string') ? msg.token_in_symbol
          : 'USDT';
        const roiPct = (typeof msg.roi_pct === 'number') ? msg.roi_pct
          : (typeof msg.profit_pct === 'number') ? msg.profit_pct
          : (parsed.profit_pct != null && isFinite(parsed.profit_pct)) ? parsed.profit_pct
          : (spent != null && isFinite(spent) && spent !== 0 && profit != null && isFinite(profit)) ? (Number(profit) / Number(spent) * 100) : null;
        const profitOk = (profit != null && Number.isFinite(profit) && Math.abs(Number(profit)) < 1e6);
        const spentOk = (spent != null && Number.isFinite(spent) && Number(spent) > 0 && Math.abs(Number(spent)) < 1e8);
        if (profitOk){
          profitableHits += 1;
          const sym = (symFromMsg || spentSym || profitCurrency || 'USDC').toUpperCase();
          // The panel is single-currency. If the bot ever sends a different symbol,
          // we ignore it and warn instead of mixing numbers with the wrong label.
          if (sym !== profitCurrency) {
            console.warn('Ignoring profit event with different currency', {sym, profitCurrency, msg});
            addLog({ type: 'warn', time: msg.time || new Date().toISOString().slice(11,19), block: msg.block, text: `Ignored profit in ${sym} (panel currency is ${profitCurrency})` });
            return;
          }
          totalProfitBySym[sym] = Number(totalProfitBySym[sym] || 0) + Number(profit);

          // Track total spent in the input token (usually same as profit token for this scanner).
          if (spentOk){
            totalSpentBySym[sym] = Number(totalSpentBySym[sym] || 0) + Number(spent);
          }
          updateStats();
          const evt = {
            t: msg.time || new Date().toISOString().slice(11,19),
            block: msg.block,
            profit: profit,
            sym: sym,
            route: route,
            spent: spent,
            spent_sym: spentSym,
            roi_pct: roiPct,
            route_short: (typeof msg.route_short === 'string') ? msg.route_short : route,
            route_full: (typeof msg.route_full === 'string') ? msg.route_full : route,
          };
          profitEvents.push(evt);
          if (profitEvents.length > MAX_PROFITS) profitEvents.shift();
          drawChart();
          pushProfitRow(evt);
          setNotice('profit', '‚úÖ Profitable opportunity found');
        } else {
          setNotice('profit', msg.text || 'profit');
        }
      }
    };

    ws.onclose = () => {
      setConn(false);
      addLog({type:'status', time: new Date().toISOString().slice(11,19), block:null, text:'Connection closed. Reconnecting...'});
      setNotice('warn', 'Connection closed. Reconnecting...');
      setTimeout(connectWS, 700);
    };

    ws.onerror = () => {
      // close will handle
    };
  }

  // -----------------------------
  // Controls
  async function post(path){
    const r = await fetch(path, {method:'POST'});
    return r.json().catch(()=>({ok:false}));
  }

  async function getConfig(){
    return fetch('/config').then(r=>r.json()).catch(()=>({ok:false}));
  }

  async function saveConfig(cfg){
    const r = await fetch('/config', {
      method:'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify(cfg || {}),
    });
    return r.json().catch(()=>({ok:false}));
  }

  function cfgFromForm(){
    // range parsing: "min..max"
    let rmin = null; let rmax = null;
    const r = String(cfgRange.value || '').trim();
    if (r.includes('..')){
      const parts = r.split('..').map(x=>x.trim());
      rmin = Number(parts[0]);
      rmax = Number(parts[1]);
    }
    return {
      rpc_urls: String(cfgRpcUrls?.value || '').trim(),
      dexes: String(cfgDexes?.value || '').trim(),
      report_currency: String(cfgReportCurrency?.value || 'USDC').trim().toUpperCase(),
      min_profit_pct: Number(cfgMinPct.value || 0),
      min_profit_abs: Number(cfgMinAbs.value || 0),
      slippage_bps: parseInt(cfgSlip.value || '0', 10),
      mev_buffer_bps: parseInt(cfgMev.value || '0', 10),
      max_gas_gwei: (cfgGas.value === '' ? null : Number(cfgGas.value)),
      concurrency: parseInt(cfgConc.value || '12', 10),
      block_budget_s: Number(cfgBudget.value || 10),
      scan_mode: String(cfgMode.value || 'auto'),

      amount_presets: (cfgAmts.value || '').trim(),

      stage1_amount: Number(cfgS1Amt.value || 1),
      stage2_top_k: parseInt(cfgTopK.value || '30', 10),
      stage2_amount_min: (rmin == null || !isFinite(rmin)) ? null : rmin,
      stage2_amount_max: (rmax == null || !isFinite(rmax)) ? null : rmax,
      stage2_max_evals: parseInt(cfgEvals.value || '6', 10),

      rpc_timeout_stage1_s: Number(cfgT1.value || 3),
      rpc_timeout_stage2_s: Number(cfgT2.value || 4),
      v2_min_reserve_ratio: Number(cfgV2Ratio.value || 0),
      v2_max_price_impact_bps: Number(cfgV2Impact.value || 0),
    };
  }

  function fillForm(cfg){
    if (cfgRpcUrls) {
      const ru = cfg.rpc_urls;
      cfgRpcUrls.value = Array.isArray(ru) ? ru.join('\n') : String(ru || '');
    }
    if (cfgDexes) {
      const dx = cfg.dexes;
      cfgDexes.value = Array.isArray(dx) ? dx.join(',') : String(dx || '');
    }
    if (cfgReportCurrency) {
      const rc = String(cfg.report_currency || 'USDC').trim().toUpperCase();
      cfgReportCurrency.value = (rc === 'USDT') ? 'USDT' : 'USDC';
      profitCurrency = cfgReportCurrency.value;
    }
    cfgMinPct.value = String(cfg.min_profit_pct ?? 0.05);
    cfgMinAbs.value = String(cfg.min_profit_abs ?? 0.05);
    cfgSlip.value = String(cfg.slippage_bps ?? 8);
    cfgMev.value = String(cfg.mev_buffer_bps ?? 5);
    cfgGas.value = (cfg.max_gas_gwei == null ? '' : String(cfg.max_gas_gwei));
    cfgConc.value = String(cfg.concurrency ?? 12);
    cfgMode.value = String(cfg.scan_mode ?? 'auto');
    cfgBudget.value = String(cfg.block_budget_s ?? 10);
    const ap = cfg.amount_presets;
    cfgAmts.value = Array.isArray(ap) ? ap.join(',') : String(ap ?? '1,3,10');

    cfgS1Amt.value = String(cfg.stage1_amount ?? 1);
    cfgTopK.value = String(cfg.stage2_top_k ?? 30);
    const rmin = cfg.stage2_amount_min ?? 0.5;
    const rmax = cfg.stage2_amount_max ?? 50;
    cfgRange.value = String(rmin) + '..' + String(rmax);
    cfgEvals.value = String(cfg.stage2_max_evals ?? 6);
    cfgT1.value = String(cfg.rpc_timeout_stage1_s ?? 3);
    cfgT2.value = String(cfg.rpc_timeout_stage2_s ?? 4);
    cfgV2Ratio.value = String(cfg.v2_min_reserve_ratio ?? 20);
    cfgV2Impact.value = String(cfg.v2_max_price_impact_bps ?? 300);
    updateStats();
    drawChart();
    rebuildProfitTable();
    schedulePersist();
  }

  function initColumnResizers(){
    if (!dealsTable) return;
    const minW = { time: 60, route: 180, spent: 90, roi: 70, profit: 90 };
    const handles = dealsTable.querySelectorAll('.colResizer');
    handles.forEach((handle) => {
      handle.addEventListener('dblclick', () => {
        const col = handle.dataset.col;
        if (!col) return;
        dealsTable.style.removeProperty(`--col-${col}`);
      });
      handle.addEventListener('pointerdown', (e) => {
        const col = handle.dataset.col;
        if (!col) return;
        const colEl = dealsTable.querySelector(`.col-${col}`);
        const startX = e.clientX;
        const startWidth = colEl ? colEl.getBoundingClientRect().width : 100;

        const onMove = (ev) => {
          const next = Math.max(minW[col] || 80, startWidth + (ev.clientX - startX));
          dealsTable.style.setProperty(`--col-${col}`, `${Math.round(next)}px`);
        };
        const onUp = () => {
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
        };
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
        e.preventDefault();
      });
    });
  }

  // Settings buttons
  saveCfgBtn.addEventListener('click', async () => {
    setNotice('status', 'Saving config...');
    const out = await saveConfig(cfgFromForm());
    if (out.ok) setNotice('status', 'Config saved');
    else setNotice('warn', 'Config save failed: ' + (out.error || 'unknown'));
  });

  applyCfgBtn.addEventListener('click', async () => {
    setNotice('status', 'Applying config (restart)...');
    const saved = await saveConfig(cfgFromForm());
    if (!saved.ok){
      setNotice('warn', 'Config save failed: ' + (saved.error || 'unknown'));
      return;
    }
    // Proper restart waits for the old bot process to fully exit before starting,
    // otherwise /start may return alreadyRunning and the new config won't apply.
    const started = await post('/restart');
    if (started.ok) setNotice('status', 'Restarted with new config');
    else setNotice('warn', 'Restart failed: ' + (started.error || 'unknown'));
  });

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    setNotice('status', 'Starting...');
    const out = await post('/start');
    if (!out.ok){
      setNotice('warn', 'Failed to start: ' + (out.error || 'unknown'));
      setRunning(false);
    }
  });

  stopBtn.addEventListener('click', async () => {
    stopBtn.disabled = true;
    setNotice('status', 'Stopping...');
    const out = await post('/stop');
    if (!out.ok){
      setNotice('warn', 'Failed to stop: ' + (out.error || 'unknown'));
    }
    // actual state will be updated by WS status message
  });

  // -----------------------------
  // Init
  const restored = restoreState();
  if (!restored) drawChart();
  initColumnResizers();
  // Load settings once on page init
  getConfig().then((c)=>{
    if (c && c.ok) fillForm(c.config || {});
  }).catch(()=>{});

  fetchServerState();
  connectWS();
</script>
</body>
</html>
