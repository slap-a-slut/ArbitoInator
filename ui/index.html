<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ArbitoInator Monitor</title>
  <!-- Modern sans + mono. If Google Fonts is blocked, fallbacks are used. -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #0b0c0f;
      --panel: rgba(18,20,26,0.92);
      --panel-2: rgba(24,26,34,0.90);
      --stroke: rgba(255,255,255,0.08);
      --text: #f5f5f7;
      --muted: #b5b7c2;
      --good: #32d74b;
      --warn: #ff9f0a;
      --bad: #ff453a;
      --blue: #0a84ff;
      --red: #ff453a;
      --shadow: 0 24px 60px rgba(0,0,0,0.45);
      --radius: 20px;

      /* Deals table columns */
      --col-time: 74px;
      --col-route: minmax(220px, 1fr);
      --col-spent: 120px;
      --col-roi: 90px;
      --col-profit: 130px;
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      font-family: "Manrope", "Avenir Next", "Helvetica Neue", sans-serif;
      background:
        radial-gradient(900px 520px at 85% -10%, rgba(10,132,255,0.20), transparent 60%),
        radial-gradient(800px 520px at 10% 110%, rgba(10,132,255,0.12), transparent 62%),
        linear-gradient(180deg, #0b0c0f 0%, #0f1116 100%);
      color: var(--text);
      min-height: 100vh;
    }

    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(600px 320px at 15% 10%, rgba(255,255,255,0.04), transparent 60%),
        radial-gradient(520px 360px at 85% 85%, rgba(255,255,255,0.03), transparent 62%);
      opacity: 0.7;
    }
    body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: linear-gradient(120deg, rgba(255,255,255,0.03), rgba(255,255,255,0.0) 35%, rgba(255,255,255,0.02));
      opacity: 0.4;
      mix-blend-mode: screen;
    }

    .frame{
      max-width: 1280px;
      margin: 24px auto;
      padding: 0 18px 28px;
    }

    .titlebar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 18px;
      padding: 18px 18px 16px;
      border-radius: calc(var(--radius) + 6px);
      background: var(--panel-2);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      position: sticky;
      top: 18px;
      z-index: 30;
    }

    .title{
      font-weight: 700;
      letter-spacing: .01em;
      font-size: clamp(20px, 2.6vw, 36px);
      margin:0;
      line-height:1.15;
    }

    .mono{
      font-family: "IBM Plex Mono", "SF Mono", "Menlo", "Monaco", "Consolas", monospace;
    }

    .readonlyList{
      font-family: "IBM Plex Mono", "SF Mono", "Menlo", "Monaco", "Consolas", monospace;
      font-size: 11px;
      line-height: 1.4;
      color: rgba(255,255,255,0.85);
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 8px;
      max-height: 90px;
      overflow: auto;
      white-space: pre;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.03);
      color: var(--muted);
      min-width: 280px;
      justify-content: space-between;
    }
    .pill b{ color: var(--text); font-weight: 700; }
    .dot{
      width: 10px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.2);
      box-shadow: 0 0 0 6px rgba(255,255,255,0.04);
    }
    .dot.ok{ background: var(--good); box-shadow: 0 0 0 6px rgba(50,215,75,0.20); }
    .dot.off{ background: rgba(255,255,255,0.22); box-shadow: 0 0 0 6px rgba(255,255,255,0.06); }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr 0.95fr;
      gap: 20px;
      margin-top: 16px;
      align-items: start;
    }

    .card{
      border-radius: var(--radius);
      background: var(--panel);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .cardHeader{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
    }

    .cardHeader h2{
      margin:0;
      font-size: 13px;
      letter-spacing: .02em;
      text-transform: none;
      color: var(--muted);
      font-weight: 600;
    }

    /* Left column becomes an operator stack: logs -> chart -> deals */
    .leftStack{
      display:flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      min-height: 0;
    }

    .logFeed{
      height: 320px;
      overflow:auto;
      padding: 12px 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
    }

    .chartBox{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
      overflow:hidden;
      height: 220px;
    }

    .dealsWrap{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
      overflow:hidden;
      min-height: 0;
      flex: 1;
      display:flex;
      flex-direction: column;
    }

    .tableHead{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .tableHead h3{
      margin:0;
      font-size: 12px;
      letter-spacing: .04em;
      text-transform: none;
      color: var(--muted);
      font-weight: 600;
    }

    .dealsBody{
      overflow:auto;
      min-height: 0;
      padding: 0 8px 10px;
    }

    .logItem{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(12,14,18,0.7);
      margin-bottom: 10px;
    }
    .logItem .meta{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content: space-between;
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 6px;
    }
    .logItem .text{ font-size: 13px; line-height: 1.35; }

    .badge{
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      white-space: nowrap;
    }
    .badge.good{ color: var(--good); border-color: rgba(50,215,75,0.35); background: rgba(50,215,75,0.10);} 
    .badge.warn{ color: var(--warn); border-color: rgba(255,159,10,0.35); background: rgba(255,159,10,0.10);} 
    .badge.bad{ color: var(--bad); border-color: rgba(255,69,58,0.35); background: rgba(255,69,58,0.10);} 
    .badge.blue{ color: var(--blue); border-color: rgba(10,132,255,0.45); background: rgba(10,132,255,0.12);} 

    .rightTop{
      padding: 14px 16px 10px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .kv{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(8,10,14,0.6);
      border: 1px solid rgba(255,255,255,0.06);
    }
    .kv span{ color: var(--muted); font-size: 12px; }
    .kv b{ font-size: 14px; }

    .notice{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(8,10,14,0.6);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .notice .left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .notice .msg{
      color: var(--muted);
      font-size: 13px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .buttons{
      display:flex;
      gap: 12px;
      padding: 10px 16px 14px;
      align-items:center;
      justify-content: center;
    }

    .btn{
      width: auto;
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 600;
      letter-spacing: .01em;
      text-transform: none;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, opacity .12s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn:hover{ background: rgba(255,255,255,0.08); }
    .btn.primary{ 
      background: linear-gradient(180deg, rgba(10,132,255,0.30), rgba(10,132,255,0.14));
      border-color: rgba(10,132,255,0.45);
      box-shadow: 0 0 0 1px rgba(10,132,255,0.06), 0 0 22px rgba(10,132,255,0.12);
    } 
    .btn.danger{ 
      background: linear-gradient(180deg, rgba(255,69,58,0.26), rgba(255,69,58,0.12));
      border-color: rgba(255,69,58,0.45);
      box-shadow: 0 0 0 1px rgba(255,69,58,0.06), 0 0 22px rgba(255,69,58,0.12);
    } 
    .btn:disabled{
      opacity: .40;
      cursor: not-allowed;
      transform: none;
    }
    .btn.tiny{
      padding: 6px 10px;
      font-size: 12px;
    }

    .dashboard{
      padding: 12px 12px 14px;
    }

    .stats{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }
    .stat{
      padding: 12px 12px;
      border-radius: 16px;
      background: rgba(10,12,16,0.7);
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.02);
    }
    .stat .k{ color: rgba(255,255,255,0.70); font-size: 12px; }
    .stat .v{ font-size: 18px; font-weight: 700; margin-top: 4px; }
    .mempoolPanel{ margin-top:16px; background: rgba(10,12,16,0.55); border:1px solid rgba(255,255,255,0.06); border-radius:16px; padding:12px; }
    .mempoolPanel .panelHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .mempoolPanel .panelHead h3{ margin:0; font-size:13px; letter-spacing:0.04em; text-transform:uppercase; color:rgba(255,255,255,0.7); }
    .mempoolStats .v{ font-size:14px; }
    .mempoolLists{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; margin-top:10px; }
    .mempoolList{ background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.06); border-radius:12px; padding:8px; min-height:120px; }
    .mempoolList .label{ font-size:11px; color: rgba(255,255,255,0.6); margin-bottom:6px; text-transform:uppercase; letter-spacing:0.04em; }
    .mempoolList .list{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; line-height:1.35; max-height:160px; overflow:auto; white-space:pre; }
    .mempoolList .row{ padding:2px 4px; border-radius:6px; cursor:pointer; }
    .mempoolList .row:hover{ background: rgba(255,255,255,0.06); }
    .mempoolDetail{ margin-top:10px; background: rgba(8,10,14,0.5); border:1px solid rgba(255,255,255,0.06); border-radius:12px; padding:8px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; line-height:1.35; white-space:pre-wrap; max-height:160px; overflow:auto; }

    .chartWrap{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(8,10,14,0.6);
      padding: 10px;
      margin-bottom: 10px;
    }

    canvas{ width:100%; height: 210px; display:block; }

    .table{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(10,12,16,0.6);
      overflow: auto;
    }

    /* Profit rows live inside the left operator stack; scrolling is handled by .dealsBody */
    #profitRows{ overflow: visible; max-height: none; }

    .routeDetails{ width: 100%; }
    .routeDetails summary{
      cursor: pointer;
      list-style: none;
      outline: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .routeDetails summary::-webkit-details-marker{ display: none; }
    .routeFull{
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.80);
      font-size: 12px;
      overflow-x: auto;
      white-space: nowrap;
    }
    .row{
      display:grid;
      grid-template-columns: var(--col-time) var(--col-route) var(--col-spent) var(--col-roi) var(--col-profit);
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      align-items:center;
      font-size: 13px;
    }
    .row.header{
      position: sticky;
      top: 0;
      z-index: 1;
      background: rgba(16,18,24,0.92);
      backdrop-filter: blur(6px);
    }
    .row > div{ min-width: 0; }
    .row:last-child{ border-bottom: none; }
    .row .muted{ color: var(--muted); font-size: 12px; }
    .row .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .row.header{
      position: relative;
      user-select: none;
    }
    .row.header .col{
      position: relative;
      padding-right: 10px;
    }
    .colResizer{
      position: absolute;
      top: -6px;
      right: -8px;
      width: 14px;
      height: calc(100% + 12px);
      cursor: col-resize;
      touch-action: none;
      z-index: 2;
    }
    .colResizer::after{
      content:"";
      position: absolute;
      top: 8px;
      bottom: 8px;
      left: 6px;
      width: 1px;
      background: rgba(255,255,255,0.12);
    }

    /* Route cell: long strings should not break the layout */
    .routeCell{ min-width: 0; }
    .routeCell .scroll{
      overflow-x: auto;
      white-space: nowrap;
      padding-bottom: 2px;
      scrollbar-width: thin;
    }
    .routeCell details{ display: inline; }
    .routeCell summary{
      cursor: pointer;
      list-style: none;
      color: rgba(255,255,255,0.88);
    }
    .routeCell summary::-webkit-details-marker{ display:none; }
    .routeCell .full{
      display: block;
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(12,14,18,0.8);
      border: 1px solid rgba(255,255,255,0.06);
      white-space: pre;
      overflow-x: auto;
    }

    #rpcStatsBody{
      overflow-x: auto;
      white-space: nowrap;
      display: block;
      padding-bottom: 2px;
      scrollbar-width: thin;
    }

    /* Settings */
    .settings{
      margin-top: 12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(10,12,16,0.6);
      padding: 12px;
    }
    .settings h3{
      margin: 0 0 10px;
      font-size: 12px;
      letter-spacing: .02em;
      text-transform: none;
      color: var(--muted);
    }
    .settingsGrid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .field{ display:flex; flex-direction:column; gap:6px; }
    .field label{ font-size: 12px; color: var(--muted); }
    .field input,
    .field select,
    .field textarea{
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      padding: 10px 10px;
      outline: none;
      font-size: 13px;
    }
    .field input:focus,
    .field select:focus,
    .field textarea:focus{
      border-color: rgba(10,132,255,0.55);
      box-shadow: 0 0 0 2px rgba(10,132,255,0.15);
    }
    .field small{ color: rgba(255,255,255,0.55); font-size: 11px; }
    .checkRow{ display:flex; align-items:center; gap:8px; }
    .checkRow input{ accent-color: var(--accent); }
    .settingsActions{ display:flex; gap: 10px; margin-top: 12px; }

    /* New layout */
    .topbar{
      position: sticky;
      top: 0;
      z-index: 20;
      display:flex;
      align-items:center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
      padding: 14px 16px;
      border-radius: calc(var(--radius) + 6px);
      background: var(--panel-2);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
    }
    .brand{ display:flex; flex-direction: column; gap: 6px; }
    .badgeRow{ display:flex; align-items:center; gap: 8px; flex-wrap: wrap; }
    .topStatus{ display:flex; gap: 10px; flex-wrap: wrap; align-items:center; }
    .topActions{ display:flex; gap: 8px; flex-wrap: wrap; align-items:center; }
    .topbar .pill{ min-width: 180px; }
    .statusRow{ display:flex; align-items:center; gap: 10px; }
    .statusText{ display:flex; flex-direction: column; min-width: 0; }
    .statusText span{ font-size: 12px; color: var(--muted); }
    .miniStatus{ display:flex; flex-direction: column; gap: 2px; min-width: 0; }
    .miniStatus span{ font-size: 11px; color: var(--muted); }
    .miniStatus b{ font-size: 13px; }

    .nowPanel{ margin-top: 16px; padding: 14px; }
    .nowHeader{ display:flex; align-items:center; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .nowMeta{ display:flex; gap: 12px; flex-wrap: wrap; }
    .kpiGrid{ display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 10px; margin-top: 12px; }
    .kpiCard{ border-radius: 16px; border: 1px solid rgba(255,255,255,0.06); background: rgba(8,10,14,0.55); padding: 12px; }
    .kpiTitle{ font-size: 12px; color: rgba(255,255,255,0.7); letter-spacing: .04em; text-transform: uppercase; margin-bottom: 8px; }
    .kpiRow{ display:flex; align-items:center; justify-content: space-between; gap: 10px; font-size: 12px; color: var(--muted); }
    .kpiRow b{ color: var(--text); font-weight: 600; }

    .warningsStrip{ display:flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .warnPill{
      display: none;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,159,10,0.12);
      border: 1px solid rgba(255,159,10,0.35);
      color: var(--warn);
      font-size: 11px;
      font-weight: 600;
    }
    .warnPill.show{ display: inline-flex; }

    .splitLists{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 10px; margin-top: 12px; }
    .listCard{ border-radius: 14px; border: 1px solid rgba(255,255,255,0.06); background: rgba(8,10,14,0.55); padding: 10px; }
    .listCard .label{ font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 6px; text-transform: uppercase; letter-spacing: .04em; }
    .listCard .list{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 11px; line-height: 1.35; max-height: 160px; overflow: auto; white-space: pre; }

    .secondaryStatsDetails{ margin-top: 10px; }
    .secondaryStatsDetails summary{ cursor: pointer; font-size: 12px; color: var(--muted); }
    .secondaryStatsDetails[open] summary{ color: var(--text); }
    .secondaryGrid{ display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 8px; margin-top: 8px; }
    .statMini{ display:flex; flex-direction: column; gap: 4px; padding: 8px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.06); background: rgba(8,10,14,0.5); }
    .statMini span{ font-size: 11px; color: var(--muted); }
    .statMini b{ font-size: 13px; color: var(--text); }

    .rpcDetails{ margin-top: 10px; }
    .rpcDetails summary{ cursor: pointer; font-size: 12px; color: var(--muted); }
    .rpcDetails[open] summary{ color: var(--text); }

    .opsPanel{ margin-top: 16px; }
    .opsStack{ display:flex; flex-direction: column; gap: 12px; }
    .opsCard > summary{ padding: 10px 14px; }

    .settingsPanel{ margin-top: 16px; padding: 12px; }
    .settingsHeader{ display:flex; align-items:flex-start; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .settingsHeadLeft{ display:flex; flex-direction: column; gap: 10px; }
    .settingsSearch{ display:flex; align-items:center; gap: 6px; }
    .settingsSearch input{ min-width: 240px; }
    .quickButtons{ display:flex; gap: 8px; flex-wrap: wrap; }

    .sectionCard{
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 16px;
      background: rgba(8,10,14,0.55);
      margin-top: 12px;
      overflow: hidden;
    }
    .sectionCard > summary{
      list-style: none;
      cursor: pointer;
      padding: 10px 14px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      user-select: none;
    }
    .sectionCard[open] > summary{ background: rgba(255,255,255,0.03); }
    .sectionTitle{ display:flex; flex-direction: column; gap: 2px; font-size: 13px; }
    .sectionHint{ font-size: 11px; color: rgba(255,255,255,0.55); }
    .sectionBody{ padding: 12px 14px; border-top: 1px solid rgba(255,255,255,0.06); }
    .basicGrid, .advancedGrid{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 10px; }

    .advancedToggle{ margin-top: 10px; }
    .advancedToggle > summary{
      list-style: none;
      cursor: pointer;
      font-size: 12px;
      color: var(--muted);
      padding: 8px 0;
      user-select: none;
    }
    .advancedToggle[open] > summary{ color: var(--text); }

    .toggleRow{ display:flex; gap: 12px; flex-wrap: wrap; align-items:center; }
    .warnBadge{
      display:none;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(255,159,10,0.12);
      border: 1px solid rgba(255,159,10,0.35);
      color: var(--warn);
      font-size: 10px;
      font-weight: 600;
    }
    .warnBadge.show{ display:inline-flex; }

    .field.hidden{ display:none; }
    .field.match{ outline: 1px solid rgba(10,132,255,0.6); border-radius: 12px; padding: 6px; }

    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .topbar{ position: static; }
      .pill{ min-width: auto; width: 100%; }
      .logFeed{ height: 360px; }
      .chartBox{ height: 200px; }
      .kpiGrid{ grid-template-columns: 1fr; }
      .splitLists{ grid-template-columns: 1fr; }
      .secondaryGrid{ grid-template-columns: 1fr; }
      .basicGrid, .advancedGrid{ grid-template-columns: 1fr; }
      .settingsSearch input{ min-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="frame">
    <header class="topbar">
      <div class="brand">
        <h1 class="title">ArbitoInator/АрбитоИнатор</h1>
        <div class="badgeRow">
          <span class="badge" id="currentPresetBadge">preset: —</span>
          <span class="badge blue" id="currentScanSourceBadge">scan: —</span>
        </div>
      </div>
      <div class="topStatus">
        <div class="pill" title="Connection status">
          <div class="statusRow">
            <div id="connDot" class="dot off"></div>
            <div class="statusText">
              <span>Connection</span>
              <b id="connText">offline</b>
            </div>
          </div>
          <div class="badge" id="runBadge">stopped</div>
        </div>

        <div class="pill" title="Process uptime">
          <div class="statusText">
            <span>Uptime</span>
            <b id="uptimeText" class="mono">00:00:00</b>
          </div>
          <div class="badge blue" id="uptimeState">—</div>
        </div>

        <div class="pill" title="RPC + WS status">
          <div class="miniStatus">
            <span>RPC</span>
            <b id="rpcStatusBadge">—</b>
          </div>
          <div class="miniStatus">
            <span>WS</span>
            <b id="wsStatusBadge">—</b>
          </div>
        </div>
      </div>

      <div class="topActions">
        <button id="startBtn" class="btn primary" disabled>start</button>
        <button id="stopBtn" class="btn danger" disabled>stop</button>
        <button id="applyCfgBtnTop" class="btn primary">apply & restart</button>
        <button id="copyDebugBtn" class="btn">Copy debug summary</button>
        <button id="copyPackBtn" class="btn">Copy Assistant Pack</button>
      </div>
    </header>

    <section class="card nowPanel">
      <div class="nowHeader">
        <div class="nowMeta">
          <div class="kv">
            <span>Last scanned block</span>
            <b class="mono" id="lastBlock">—</b>
          </div>
          <div class="kv">
            <span>State</span>
            <b id="stateText" class="mono">stopped</b>
          </div>
        </div>
        <div class="notice" id="notice">
          <div class="left">
            <span class="badge" id="noticeIcon" aria-hidden="true">ℹ</span>
            <div class="msg" id="noticeText">No data yet. Press Start to begin.</div>
          </div>
          <div class="badge" id="opBadge">idle</div>
        </div>
      </div>

      <div class="kpiGrid">
        <div class="kpiCard">
          <div class="kpiTitle">Mempool</div>
          <div class="kpiRow"><span>WS</span><b id="mpWs">—</b></div>
          <div class="kpiRow"><span>Hashes/sec</span><b id="mpRate">0</b></div>
          <div class="kpiRow"><span>Fetch success</span><b id="mpFetch">0%</b></div>
          <div class="kpiRow"><span>Decoded swaps</span><b id="mpDecoded">0</b></div>
        </div>
        <div class="kpiCard">
          <div class="kpiTitle">Triggers</div>
          <div class="kpiRow"><span>Queued / Running (now)</span><b id="mpTriggers">0/0</b></div>
          <div class="kpiRow"><span>Total seen / processed</span><b id="mpTotal">0/0</b></div>
          <div class="kpiRow"><span>Dropped / TTL</span><b id="mpDropped">0/0</b></div>
          <div class="kpiRow"><span>Last classification</span><b id="mpLastOutcome">—</b></div>
          <div class="kpiRow"><span>Avg trigger latency</span><b id="mpLatency">—</b></div>
        </div>
        <div class="kpiCard">
          <div class="kpiTitle">Hits</div>
          <div class="kpiRow"><span>Profitable hits</span><b id="statHits">0</b></div>
          <div class="kpiRow"><span>Total profit</span><b id="statProfit">0.000000</b></div>
          <div class="kpiRow"><span>Avg ROI</span><b id="statRoi">0.00%</b></div>
          <div class="kpiRow"><span>Last route</span><b id="lastHitRoute">—</b></div>
          <div class="kpiRow"><span>Backend</span><b id="lastHitBackend">—</b></div>
          <div class="kpiRow"><span>Persistent hits</span><b id="mpPersist">—</b></div>
        </div>
      </div>

      <details class="secondaryStatsDetails">
        <summary>More stats</summary>
        <div class="secondaryGrid">
          <div class="statMini"><span>Blocks scanned</span><b id="statBlocks">0</b></div>
          <div class="statMini"><span>Total spent</span><b id="statSpent">0.000</b></div>
          <div class="statMini"><span>Raw opps</span><b id="statRaw">0</b></div>
          <div class="statMini"><span>After slippage+MEV</span><b id="statSafety">0</b></div>
          <div class="statMini"><span>After gas/limits</span><b id="statGas">0</b></div>
          <div class="statMini"><span>Ready to execute</span><b id="statReady">0</b></div>
        </div>
      </details>

      <div class="warningsStrip" id="warningsStrip">
        <span class="warnPill" id="warnScheduledZero">Triggers scheduled=0 streak</span>
        <span class="warnPill" id="warnWsDown">Mempool WS offline</span>
        <span class="warnPill" id="warnPersistentHit">Persistent-hit warning</span>
        <span class="warnPill" id="warnRequireCrossDex">Require cross-DEX enabled</span>
      </div>

      <div class="splitLists">
        <div class="listCard">
          <div class="label">Decoded swaps (last 10)</div>
          <div class="list" id="mpSwaps">—</div>
        </div>
        <div class="listCard">
          <div class="label">Trigger scans (last 10)</div>
          <div class="list" id="mpTriggerScans">—</div>
        </div>
      </div>

      <details class="rpcDetails">
        <summary>RPC pool details</summary>
        <div id="rpcStatsBody" class="mono">—</div>
      </details>
      <div class="mempoolDetail" id="mpDetail">Select a trigger to view details.</div>
    </section>

    <section class="card opsPanel">
      <details class="sectionCard opsCard" data-section="ops" open>
        <summary>
          <div class="sectionTitle">
            <span>Ops feed</span>
            <span class="badge blue" id="logCount">0</span>
          </div>
          <span class="badge">logs</span>
        </summary>
        <div class="sectionBody">
          <div class="opsStack">
            <div class="logFeed" id="logs" aria-label="Logs"></div>

            <div class="chartBox" title="Profit timeline (recent events)">
              <canvas id="profitChart" width="900" height="260"></canvas>
            </div>

            <div class="dealsWrap" aria-label="Latest profit events">
              <div class="tableHead">
                <h3>Deals</h3>
                <span class="badge" id="dealsHint">latest</span>
              </div>
              <div class="table" id="dealsTable" style="margin: 0 8px 8px;">
                <div class="row header" style="background: rgba(255,255,255,0.04); font-weight:800; color: rgba(255,255,255,0.75);">
                  <div class="col col-time muted">Time<span class="colResizer" data-col="time"></span></div>
                  <div class="col col-route muted">Route<span class="colResizer" data-col="route"></span></div>
                  <div class="col col-spent muted" style="text-align:right;">Spent<span class="colResizer" data-col="spent"></span></div>
                  <div class="col col-roi muted" style="text-align:right;">ROI<span class="colResizer" data-col="roi"></span></div>
                  <div class="col col-profit muted" style="text-align:right;">Profit</div>
                </div>
                <div class="dealsBody" id="profitRows"></div>
              </div>
            </div>
          </div>
        </div>
      </details>
    </section>

    <section class="card settingsPanel" id="settings">
      <div class="settingsHeader">
        <div class="settingsHeadLeft">
          <h2>Settings</h2>
          <div class="settingsSearch">
            <input id="settingsSearch" type="search" placeholder="Search settings..." />
            <button id="settingsSearchClear" class="btn tiny">Clear</button>
          </div>
        </div>
        <div class="quickButtons">
          <button id="recDebugBtn" class="btn">Debug (fast signal)</button>
          <button id="recCrossDexBtn" class="btn">Cross-DEX hunt</button>
          <button id="recStrictBtn" class="btn">Strict realistic</button>
        </div>
      </div>

      <details class="sectionCard" data-section="mode" open>
        <summary>
          <div class="sectionTitle">
            <span>Mode & Presets</span>
            <span class="sectionHint">Quick start + run context</span>
          </div>
          <span class="badge">basic</span>
        </summary>
        <div class="sectionBody">
          <div class="basicGrid">
            <div class="field" style="grid-column: 1 / -1;">
              <label for="cfgPreset">Preset</label>
              <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                <select id="cfgPreset">
                  <option value="">— select preset —</option>
                </select>
                <button id="applyPresetBtn" class="btn">Apply preset</button>
              </div>
              <small id="cfgPresetDesc">Select a preset to populate the fields below.</small>
            </div>
            <div class="field">
              <label for="cfgScanSource">Scan source</label>
              <select id="cfgScanSource">
                <option value="block">block scanning</option>
                <option value="mempool">mempool-triggered</option>
                <option value="hybrid">hybrid</option>
              </select>
              <small>block = current pipeline; mempool = pending tx triggers; hybrid = both</small>
            </div>
            <div class="field">
              <label for="cfgMode">Scan mode</label>
              <select id="cfgMode">
                <option value="auto">auto (Stage1 + Stage2 optimize)</option>
                <option value="fixed">fixed (preset amounts)</option>
              </select>
              <small>auto = fast + smart; fixed = brute force</small>
            </div>
            <div class="field">
              <label for="cfgReportCurrency">Reporting currency</label>
              <select id="cfgReportCurrency">
                <option value="USDC">USDC</option>
                <option value="USDT">USDT</option>
              </select>
              <small>Stats are shown in this currency.</small>
            </div>
            <div class="field">
              <label for="cfgBudget">Block budget (sec)</label>
              <input id="cfgBudget" type="number" step="0.5" min="1" />
              <small>hard limit per block (prevents hanging)</small>
            </div>
          </div>

          <details class="advancedToggle" data-advanced="mode">
            <summary>Advanced</summary>
            <div class="advancedGrid">
              <div class="field">
                <label for="cfgAmts">Amounts (comma list)</label>
                <input id="cfgAmts" type="text" placeholder="1,3,10" />
                <small>token_in units; increases search coverage</small>
              </div>
              <div class="field">
                <label for="cfgS1Amt">Stage1 amount</label>
                <input id="cfgS1Amt" type="number" step="0.1" min="0" />
                <small>cheap filter amount</small>
              </div>
              <div class="field">
                <label for="cfgTopK">Stage2 top-K</label>
                <input id="cfgTopK" type="number" step="1" min="1" max="500" />
                <small>how many routes get optimized</small>
              </div>
              <div class="field">
                <label for="cfgRange">Stage2 amount range</label>
                <input id="cfgRange" type="text" placeholder="0.5..50" />
                <small>min..max (units of token_in)</small>
              </div>
              <div class="field">
                <label for="cfgEvals">Stage2 max evals</label>
                <input id="cfgEvals" type="number" step="1" min="2" max="12" />
                <small>RPC calls per route for optimization</small>
              </div>
            </div>
          </details>
        </div>
      </details>

      <details class="sectionCard" data-section="routing" open>
        <summary>
          <div class="sectionTitle">
            <span>Routing & Search</span>
            <span class="sectionHint">Routes, hops, and beam controls</span>
          </div>
          <span class="badge">basic</span>
        </summary>
        <div class="sectionBody">
          <div class="basicGrid">
            <div class="field" style="grid-column: 1 / -1;">
              <label for="cfgDexes">DEX adapters</label>
              <input id="cfgDexes" type="text" class="mono" placeholder="univ3,univ2,sushiswap" />
              <small>Comma list. Order matters only for display; best quote is chosen per hop.</small>
            </div>
            <div class="field">
              <label for="cfgEnableMultidex">Multi-DEX routing</label>
              <label class="checkRow">
                <input id="cfgEnableMultidex" type="checkbox" />
                <span>enable multi-DEX + beam search</span>
              </label>
              <small>off = UniV3-only (legacy)</small>
            </div>
            <div class="field">
              <label for="cfgMaxHops">Max hops</label>
              <input id="cfgMaxHops" type="number" step="1" min="2" max="4" />
              <small>2–4; higher = more cycles</small>
            </div>
            <div class="field">
              <label for="cfgBeamK">Beam K</label>
              <input id="cfgBeamK" type="number" step="1" min="1" max="50" />
              <small>max combined paths per route</small>
            </div>
          </div>

          <details class="advancedToggle" data-advanced="routing">
            <summary>Advanced</summary>
            <div class="advancedGrid">
              <div class="field">
                <label for="cfgEdgeTopM">Edge top-M</label>
                <input id="cfgEdgeTopM" type="number" step="1" min="1" max="5" />
                <small>top quotes per hop (trigger scans use per-DEX cap)</small>
              </div>
              <div class="field">
                <label for="cfgProbeAmount">Probe amount</label>
                <input id="cfgProbeAmount" type="number" step="0.1" min="0" />
                <small>prefilter amount in base token units</small>
              </div>
            </div>
          </details>
        </div>
      </details>

      <details class="sectionCard" data-section="mempool" open>
        <summary>
          <div class="sectionTitle">
            <span>Mempool & Triggers</span>
            <span class="sectionHint">Pending tx filters and trigger focus</span>
          </div>
          <span class="badge">basic</span>
        </summary>
        <div class="sectionBody">
          <div class="basicGrid">
            <div class="field" style="grid-column: 1 / -1;">
              <label for="cfgMempoolWs">Mempool WS URLs</label>
              <textarea id="cfgMempoolWs" rows="2" class="mono" placeholder="wss://rpc1
wss://rpc2" style="width:100%; resize:vertical;"></textarea>
              <small>Public WS endpoints for pending tx stream (one per line or comma-separated).</small>
            </div>
            <div class="field">
              <label for="cfgMempoolWatchPreset">Mempool watch preset</label>
              <select id="cfgMempoolWatchPreset">
                <option value="core">core (Uni + Sushi)</option>
                <option value="extended">extended (core + universal + aggregators)</option>
              </select>
              <small>Defines which router contracts are watched.</small>
            </div>
            <div class="field">
              <label for="cfgMempoolWatchMode">Watch mode</label>
              <select id="cfgMempoolWatchMode">
                <option value="strict">strict (router OR known selector)</option>
                <option value="routers_only">routers only</option>
              </select>
              <small>strict keeps selector pre-check for non-router txs.</small>
            </div>
            <div class="field">
              <label for="cfgMempoolMinUsd">Mempool min value (USD)</label>
              <input id="cfgMempoolMinUsd" type="number" step="1" min="0" />
              <small>ignore tiny swaps (stables/WETH heuristic)</small>
            </div>
            <div class="field">
              <label class="checkRow">
                <input id="cfgMempoolAllowUnknown" type="checkbox" />
                <span>Allow unknown-token triggers</span>
              </label>
              <small>Allow triggers when USD value is unknown (testing).</small>
            </div>
            <div class="field">
              <label class="checkRow">
                <input id="cfgMempoolRawMinEnabled" type="checkbox" />
                <span>Enable raw min thresholds</span>
              </label>
              <small>Apply per-token raw minimums after USD check.</small>
            </div>
            <div class="field">
              <label for="cfgMempoolBudget">Trigger scan budget (s)</label>
              <input id="cfgMempoolBudget" type="number" step="0.1" min="0.5" />
              <small>short pre-block scan per trigger</small>
            </div>
            <div class="field" style="grid-column: 1 / -1;">
              <label>Watched routers (read-only)</label>
              <div class="readonlyList" id="cfgMempoolWatchedRouters">—</div>
              <small>Derived from the active watch preset and/or runtime status.</small>
            </div>
            <div class="field" style="grid-column: 1 / -1;">
              <label>Trigger bias (mempool)</label>
              <div class="toggleRow">
                <label class="checkRow">
                  <input id="cfgTriggerPreferCrossDex" type="checkbox" />
                  <span>Prefer cross-DEX routes (mempool)</span>
                </label>
                <label class="checkRow">
                  <input id="cfgTriggerRequireCrossDex" type="checkbox" />
                  <span>Require cross-DEX routes (mempool)</span>
                </label>
                <label class="checkRow">
                  <input id="cfgTriggerCrossDexFallback" type="checkbox" />
                  <span>Fallback to same-DEX if none</span>
                </label>
                <span class="warnBadge" id="requireCrossDexWarn">May result in scheduled=0 on public RPC</span>
                <label class="checkRow">
                  <input id="cfgTriggerRequire3Hops" type="checkbox" />
                  <span>Require 3-hop routes for triggers</span>
                </label>
              </div>
              <small>Hard filter keeps only routes using >=2 distinct DEXes.</small>
            </div>
            <div class="field">
              <label class="checkRow">
                <input id="cfgTriggerBaseFallback" type="checkbox" />
                <span>Base fallback (USDC/USDT/DAI)</span>
              </label>
              <small>Use fallback base if primary produces no cycles.</small>
            </div>
            <div class="field">
              <label class="checkRow">
                <input id="cfgTriggerAllowTwoHop" type="checkbox" />
                <span>Allow 2-hop fallback</span>
              </label>
              <small>Try 2-hop when 3-hop yields zero candidates.</small>
            </div>
          </div>

          <details class="advancedToggle" data-advanced="mempool">
            <summary>Advanced</summary>
            <div class="advancedGrid">
              <div class="field">
                <label for="cfgMempoolInflight">Mempool max inflight</label>
                <input id="cfgMempoolInflight" type="number" step="1" min="10" />
                <small>hash queue size limit</small>
              </div>
              <div class="field">
                <label for="cfgMempoolFetchConc">Mempool fetch concurrency</label>
                <input id="cfgMempoolFetchConc" type="number" step="1" min="1" />
                <small>tx fetch parallelism</small>
              </div>
              <div class="field">
                <label for="cfgMempoolDedup">Mempool dedup TTL (s)</label>
                <input id="cfgMempoolDedup" type="number" step="1" min="30" />
                <small>avoid duplicate hashes</small>
              </div>
              <div class="field">
                <label for="cfgTriggerConnectors">Trigger connectors</label>
                <input id="cfgTriggerConnectors" class="mono" placeholder="WETH,USDC,USDT,DAI" />
                <small>extra tokens included in trigger universe</small>
              </div>
              <div class="field">
                <label for="cfgTriggerMaxCandidatesRaw">Trigger max candidates (raw)</label>
                <input id="cfgTriggerMaxCandidatesRaw" type="number" step="1" min="10" />
                <small>caps route skeletons before quoting</small>
              </div>
            </div>
          </details>
        </div>
      </details>

      <details class="sectionCard" data-section="sim" open>
        <summary>
          <div class="sectionTitle">
            <span>Simulation & Safety</span>
            <span class="sectionHint">Profit thresholds and guardrails</span>
          </div>
          <span class="badge">basic</span>
        </summary>
        <div class="sectionBody">
          <div class="basicGrid">
            <div class="field">
              <label for="cfgMinPct">Min profit % (of input)</label>
              <input id="cfgMinPct" type="number" step="0.01" min="0" />
              <small>e.g. 0.05 = 0.05%</small>
            </div>
            <div class="field">
              <label for="cfgMinAbs">Min profit absolute</label>
              <input id="cfgMinAbs" type="number" step="0.001" min="0" />
              <small>in base token units (USDC/USDT/DAI)</small>
            </div>
            <div class="field">
              <label for="cfgSlip">Slippage safety (bps)</label>
              <input id="cfgSlip" type="number" step="1" min="0" />
              <small>5 = 0.05%</small>
            </div>
            <div class="field">
              <label for="cfgMev">MEV buffer (bps)</label>
              <input id="cfgMev" type="number" step="1" min="0" />
              <small>extra safety margin on top of slippage</small>
            </div>
            <div class="field">
              <label for="cfgGas">Max gas (gwei)</label>
              <input id="cfgGas" type="number" step="1" min="0" placeholder="(no limit)" />
              <small>empty = don't skip blocks</small>
            </div>
          </div>

          <details class="advancedToggle" data-advanced="sim">
            <summary>Advanced</summary>
            <div class="advancedGrid">
              <div class="field">
                <label for="cfgSimProfile">Sim profile</label>
                <select id="cfgSimProfile">
                  <option value="">default</option>
                  <option value="debug">debug</option>
                </select>
                <small>debug raises stage1 amount and relaxes thresholds</small>
              </div>
              <div class="field">
                <label for="cfgDebugFunnel">Debug funnel</label>
                <label class="checkRow">
                  <input id="cfgDebugFunnel" type="checkbox" />
                  <span>log top candidates to console</span>
                </label>
                <small>prints top 5 gross/net per block</small>
              </div>
              <div class="field">
                <label for="cfgGasOff">Gas off (diagnostic)</label>
                <label class="checkRow">
                  <input id="cfgGasOff" type="checkbox" />
                  <span>set gas_cost_in = 0</span>
                </label>
                <small>for debugging only</small>
              </div>
              <div class="field">
                <label for="cfgFixedGas">Fixed gas units</label>
                <input id="cfgFixedGas" type="number" step="1000" min="0" placeholder="0" />
                <small>override gas units (0 = auto)</small>
              </div>
              <div class="field">
                <label for="cfgSimBackend">Simulation backend</label>
                <select id="cfgSimBackend">
                  <option value="quote">quote</option>
                  <option value="eth_call">eth_call</option>
                  <option value="state_override">state_override</option>
                </select>
                <small>eth_call uses executor calldata (dry-run).</small>
              </div>
              <div class="field">
                <label for="cfgExecMode">Execution mode</label>
                <select id="cfgExecMode">
                  <option value="off">off</option>
                  <option value="dryrun">dryrun</option>
                </select>
                <small>dryrun builds tx + eth_call; no broadcast.</small>
              </div>
              <div class="field">
                <label for="cfgArbExecutorAddr">Executor address</label>
                <input id="cfgArbExecutorAddr" class="mono" placeholder="0x..." />
                <small>Contract address for eth_call simulation.</small>
              </div>
              <div class="field">
                <label for="cfgArbExecutorOwner">Executor owner (from)</label>
                <input id="cfgArbExecutorOwner" class="mono" placeholder="0x..." />
                <small>Used as eth_call sender for onlyOwner.</small>
              </div>
            </div>
          </details>
        </div>
      </details>

      <details class="sectionCard" data-section="rpc" open>
        <summary>
          <div class="sectionTitle">
            <span>RPC & Performance</span>
            <span class="sectionHint">RPC pool + throughput</span>
          </div>
          <span class="badge">basic</span>
        </summary>
        <div class="sectionBody">
          <div class="basicGrid">
            <div class="field" style="grid-column: 1 / -1;">
              <label for="cfgRpcUrls">RPC URLs (parallel pool)</label>
              <textarea id="cfgRpcUrls" rows="3" class="mono" placeholder="https://rpc1
https://rpc2
..." style="width:100%; resize:vertical;"></textarea>
              <small>One per line (or comma-separated). The bot spreads load and retries.</small>
            </div>
            <div class="field">
              <label for="cfgConc">Concurrency</label>
              <input id="cfgConc" type="number" step="1" min="1" max="200" />
              <small>RPC parallel quotes (25-50 typical)</small>
            </div>
            <div class="field">
              <label for="cfgT1">RPC timeout Stage1 (sec)</label>
              <input id="cfgT1" type="number" step="0.5" min="1" />
              <small>short timeout keeps block moving</small>
            </div>
            <div class="field">
              <label for="cfgT2">RPC timeout Stage2 (sec)</label>
              <input id="cfgT2" type="number" step="0.5" min="1" />
              <small>longer timeout to not miss profit</small>
            </div>
          </div>

          <details class="advancedToggle" data-advanced="rpc">
            <summary>Advanced</summary>
            <div class="advancedGrid">
              <div class="field">
                <label for="cfgV2Ratio">V2 min reserve ratio</label>
                <input id="cfgV2Ratio" type="number" step="1" min="0" />
                <small>reserve_in >= amount_in * ratio</small>
              </div>
              <div class="field">
                <label for="cfgV2Impact">V2 max price impact (bps)</label>
                <input id="cfgV2Impact" type="number" step="1" min="0" />
                <small>drop quotes with high impact</small>
              </div>
            </div>
          </details>
        </div>
      </details>

      <div class="settingsActions">
        <button id="saveCfgBtn" class="btn">save</button>
        <button id="applyCfgBtn" class="btn primary">apply & restart</button>
      </div>
    </section>
  </div>
<script>
  // -----------------------------
  // State
  const logsDiv = document.getElementById('logs');
  const logCount = document.getElementById('logCount');

  const connDot = document.getElementById('connDot');
  const connText = document.getElementById('connText');
  const runBadge = document.getElementById('runBadge');
  const stateText = document.getElementById('stateText');
  const currentPresetBadge = document.getElementById('currentPresetBadge');
  const currentScanSourceBadge = document.getElementById('currentScanSourceBadge');
  const rpcStatusBadge = document.getElementById('rpcStatusBadge');
  const wsStatusBadge = document.getElementById('wsStatusBadge');

  // Uptime
  const uptimeText = document.getElementById('uptimeText');
  const uptimeState = document.getElementById('uptimeState');
  let botStartedAtMs = null; // set from server (started_at_ms)

  const lastBlockEl = document.getElementById('lastBlock');
  const noticeIcon = document.getElementById('noticeIcon');
  const noticeText = document.getElementById('noticeText');
  const opBadge = document.getElementById('opBadge');

  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const applyCfgBtnTop = document.getElementById('applyCfgBtnTop');

  const statBlocks = document.getElementById('statBlocks');
  const statHits = document.getElementById('statHits');
  const statProfit = document.getElementById('statProfit');
  const statSpent = document.getElementById('statSpent');
  const statRoi = document.getElementById('statRoi');
  const statRaw = document.getElementById('statRaw');
  const statSafety = document.getElementById('statSafety');
  const statGas = document.getElementById('statGas');
  const statReady = document.getElementById('statReady');
  const rpcStatsBody = document.getElementById('rpcStatsBody');
  const lastHitRoute = document.getElementById('lastHitRoute');
  const lastHitBackend = document.getElementById('lastHitBackend');

  const profitRows = document.getElementById('profitRows');
  const canvas = document.getElementById('profitChart');
  const ctx = canvas.getContext('2d');

  const STORAGE_KEY = 'arbito_ui_state_v2';
  const MAX_LOGS = 120;
  const MAX_PROFITS = 200;
  let saveTimer = null;
  let lastSavedAtMs = 0;

  let logs = 0;
  let blocksScanned = 0;
  let lastCountedBlock = null;
  let profitableHits = 0;
  let rawOpps = 0;
  let safetyOpps = 0;
  let gasOpps = 0;
  let readyOpps = 0;
  let sanityRejectsTotal = 0;
  const rejectsByReason = {};
  const totalProfitBySym = {}; // {USDC: 1.23, USDT: 0.10, ...}
  const totalSpentBySym = {};  // {USDC: 10.0, USDT: 5.0, ...}
  let profitCurrency = 'USDC'; // currently displayed currency
  const logItems = [];
  const profitEvents = []; // {t, block, profit, route, sym}
  const mempoolSwaps = [];
  const mempoolTriggerScans = [];
  let mempoolStatus = null;
  const WATCH_PRESET_NAMES = {
    core: [
      'Uniswap V2 Router02',
      'SushiSwap Router',
      'Uniswap V3 SwapRouter',
      'Uniswap V3 SwapRouter02',
    ],
    extended: [
      'Uniswap V2 Router02',
      'SushiSwap Router',
      'Uniswap V3 SwapRouter',
      'Uniswap V3 SwapRouter02',
      'Uniswap Universal Router',
      '1inch Aggregation Router v5',
      '0x Exchange Proxy',
    ],
  };
  let selectedTriggerDetail = null;
  let triggerZeroStreak = 0;
  let lastRpcStatsAt = 0;

  // Settings elements
  const cfgRpcUrls = document.getElementById('cfgRpcUrls');
  const cfgDexes = document.getElementById('cfgDexes');
  const cfgEnableMultidex = document.getElementById('cfgEnableMultidex');
  const cfgTriggerPreferCrossDex = document.getElementById('cfgTriggerPreferCrossDex');
  const cfgTriggerRequireCrossDex = document.getElementById('cfgTriggerRequireCrossDex');
  const cfgTriggerCrossDexFallback = document.getElementById('cfgTriggerCrossDexFallback');
  const cfgTriggerRequire3Hops = document.getElementById('cfgTriggerRequire3Hops');
  const cfgTriggerBaseFallback = document.getElementById('cfgTriggerBaseFallback');
  const cfgTriggerAllowTwoHop = document.getElementById('cfgTriggerAllowTwoHop');
  const cfgTriggerConnectors = document.getElementById('cfgTriggerConnectors');
  const cfgTriggerMaxCandidatesRaw = document.getElementById('cfgTriggerMaxCandidatesRaw');
  const cfgMaxHops = document.getElementById('cfgMaxHops');
  const cfgBeamK = document.getElementById('cfgBeamK');
  const cfgEdgeTopM = document.getElementById('cfgEdgeTopM');
  const cfgProbeAmount = document.getElementById('cfgProbeAmount');
  const cfgReportCurrency = document.getElementById('cfgReportCurrency');
  const cfgMinPct = document.getElementById('cfgMinPct');
  const cfgMinAbs = document.getElementById('cfgMinAbs');
  const cfgSlip = document.getElementById('cfgSlip');
  const cfgMev = document.getElementById('cfgMev');
  const cfgGas = document.getElementById('cfgGas');
  const cfgConc = document.getElementById('cfgConc');
  const cfgScanSource = document.getElementById('cfgScanSource');
  const cfgMode = document.getElementById('cfgMode');
  const cfgBudget = document.getElementById('cfgBudget');
  const cfgAmts = document.getElementById('cfgAmts');
  const cfgS1Amt = document.getElementById('cfgS1Amt');
  const cfgTopK = document.getElementById('cfgTopK');
  const cfgRange = document.getElementById('cfgRange');
  const cfgEvals = document.getElementById('cfgEvals');
  const cfgT1 = document.getElementById('cfgT1');
  const cfgT2 = document.getElementById('cfgT2');
  const cfgV2Ratio = document.getElementById('cfgV2Ratio');
  const cfgV2Impact = document.getElementById('cfgV2Impact');
  const cfgSimProfile = document.getElementById('cfgSimProfile');
  const cfgDebugFunnel = document.getElementById('cfgDebugFunnel');
  const cfgGasOff = document.getElementById('cfgGasOff');
  const cfgFixedGas = document.getElementById('cfgFixedGas');
  const cfgSimBackend = document.getElementById('cfgSimBackend');
  const cfgExecMode = document.getElementById('cfgExecMode');
  const cfgArbExecutorAddr = document.getElementById('cfgArbExecutorAddr');
  const cfgArbExecutorOwner = document.getElementById('cfgArbExecutorOwner');
  const cfgMempoolWs = document.getElementById('cfgMempoolWs');
  const cfgMempoolWatchPreset = document.getElementById('cfgMempoolWatchPreset');
  const cfgMempoolWatchMode = document.getElementById('cfgMempoolWatchMode');
  const cfgMempoolMinUsd = document.getElementById('cfgMempoolMinUsd');
  const cfgMempoolAllowUnknown = document.getElementById('cfgMempoolAllowUnknown');
  const cfgMempoolRawMinEnabled = document.getElementById('cfgMempoolRawMinEnabled');
  const cfgMempoolInflight = document.getElementById('cfgMempoolInflight');
  const cfgMempoolFetchConc = document.getElementById('cfgMempoolFetchConc');
  const cfgMempoolDedup = document.getElementById('cfgMempoolDedup');
  const cfgMempoolBudget = document.getElementById('cfgMempoolBudget');
  const cfgMempoolWatchedRouters = document.getElementById('cfgMempoolWatchedRouters');
  const cfgPreset = document.getElementById('cfgPreset');
  const cfgPresetDesc = document.getElementById('cfgPresetDesc');
  const applyPresetBtn = document.getElementById('applyPresetBtn');
  const settingsSearch = document.getElementById('settingsSearch');
  const settingsSearchClear = document.getElementById('settingsSearchClear');
  const recDebugBtn = document.getElementById('recDebugBtn');
  const recCrossDexBtn = document.getElementById('recCrossDexBtn');
  const recStrictBtn = document.getElementById('recStrictBtn');
  const requireCrossDexWarn = document.getElementById('requireCrossDexWarn');
  const saveCfgBtn = document.getElementById('saveCfgBtn');
  const applyCfgBtn = document.getElementById('applyCfgBtn');
  const dealsTable = document.getElementById('dealsTable');
  const mpWs = document.getElementById('mpWs');
  const mpRate = document.getElementById('mpRate');
  const mpFetch = document.getElementById('mpFetch');
  const mpTriggers = document.getElementById('mpTriggers');
  const mpTotal = document.getElementById('mpTotal');
  const mpDropped = document.getElementById('mpDropped');
  const mpLatency = document.getElementById('mpLatency');
  const mpDecoded = document.getElementById('mpDecoded');
  const mpPersist = document.getElementById('mpPersist');
  const mpLastOutcome = document.getElementById('mpLastOutcome');
  const mpSwaps = document.getElementById('mpSwaps');
  const mpTriggerScans = document.getElementById('mpTriggerScans');
  const mpDetail = document.getElementById('mpDetail');
  const warnScheduledZero = document.getElementById('warnScheduledZero');
  const warnWsDown = document.getElementById('warnWsDown');
  const warnPersistentHit = document.getElementById('warnPersistentHit');
  const warnRequireCrossDex = document.getElementById('warnRequireCrossDex');
  const copyDebugBtn = document.getElementById('copyDebugBtn');
  const copyPackBtn = document.getElementById('copyPackBtn');

  // -----------------------------
  // Formatting helpers (avoid scientific notation in UI)
  function fmtAmount(value, decimals = 3){
    const n = Number(value);
    if (!Number.isFinite(n)) return '—';
    // If something explodes upstream (overflow), hide it.
    if (Math.abs(n) > 1e12) return '—';
    return n.toFixed(decimals);
  }

  function fmtPct(value, decimals = 2){
    const n = Number(value);
    if (!Number.isFinite(n)) return '—';
    // Our bot uses "0.05" to mean 0.05% (same as UI hint).
    return n.toFixed(decimals) + '%';
  }

  // Number formatting helpers (avoid scientific notation in UI)
  function formatToken(x, decimals = 3, maxAbs = 1e12){
    const num = Number(x);
    if (!Number.isFinite(num)) return '—';
    const ax = Math.abs(num);
    // For very large numbers, show exponential (rounded) instead of "∞" or "—".
    if (ax >= 1e6 && ax <= maxAbs) {
      try { return num.toExponential(2); } catch { return String(num); }
    }
    if (ax > maxAbs) return '>1e12';
    // Intl formatter avoids scientific notation for normal ranges
    try {
      return new Intl.NumberFormat('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      }).format(num);
    } catch {
      return num.toFixed(decimals);
    }
  }

  function formatPct(x, decimals = 2){
    const num = Number(x);
    if (!Number.isFinite(num)) return '—';
    const ax = Math.abs(num);
    if (ax >= 1e5 && ax <= 1e6) {
      try { return num.toExponential(2) + '%'; } catch { return String(num) + '%'; }
    }
    if (ax > 1e6) return '>1e6%';
    try {
      return new Intl.NumberFormat('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      }).format(num) + '%';
    } catch {
      return num.toFixed(decimals) + '%';
    }
  }

  function setPillVisible(el, show){
    if (!el) return;
    if (show) el.classList.add('show');
    else el.classList.remove('show');
  }

  function updateHeaderBadges(){
    if (currentPresetBadge) {
      const preset = (cfgPreset && cfgPreset.value) ? String(cfgPreset.value) : 'custom';
      currentPresetBadge.textContent = `preset: ${preset || 'custom'}`;
    }
    if (currentScanSourceBadge) {
      const src = (cfgScanSource && cfgScanSource.value) ? String(cfgScanSource.value) : 'block';
      currentScanSourceBadge.textContent = `scan: ${src}`;
    }
  }

  function updateCrossDexGuard(){
    if (!cfgTriggerRequireCrossDex || !cfgTriggerPreferCrossDex) return;
    if (cfgTriggerRequireCrossDex.checked) {
      cfgTriggerPreferCrossDex.checked = true;
      if (requireCrossDexWarn) requireCrossDexWarn.classList.add('show');
    } else {
      if (requireCrossDexWarn) requireCrossDexWarn.classList.remove('show');
    }
    setPillVisible(warnRequireCrossDex, !!cfgTriggerRequireCrossDex.checked);
  }

  function updateWarnings(){
    const wsConnected = mempoolStatus ? !!mempoolStatus.ws_connected : false;
    const persistentWarn = mempoolStatus ? !!mempoolStatus.persistent_hit_warning : false;
    const requireOn = cfgTriggerRequireCrossDex ? cfgTriggerRequireCrossDex.checked : false;
    if (warnScheduledZero) {
      warnScheduledZero.textContent = requireOn
        ? 'Triggers scheduled=0 streak — consider disabling Require cross-DEX'
        : 'Triggers scheduled=0 streak';
    }
    setPillVisible(warnWsDown, !wsConnected && !!mempoolStatus);
    setPillVisible(warnPersistentHit, persistentWarn);
    setPillVisible(warnScheduledZero, triggerZeroStreak >= 3);
    setPillVisible(warnRequireCrossDex, requireOn);
  }

  function getWatchedRouterNames(){
    const runtime = mempoolStatus && Array.isArray(mempoolStatus.mempool_watched_router_names)
      ? mempoolStatus.mempool_watched_router_names
      : null;
    if (runtime && runtime.length) return runtime;
    const preset = cfgMempoolWatchPreset ? String(cfgMempoolWatchPreset.value || '').toLowerCase() : 'core';
    return WATCH_PRESET_NAMES[preset] || WATCH_PRESET_NAMES.core;
  }

  function renderWatchedRouters(){
    if (!cfgMempoolWatchedRouters) return;
    const names = getWatchedRouterNames();
    if (!names || !names.length) {
      cfgMempoolWatchedRouters.textContent = '—';
      return;
    }
    cfgMempoolWatchedRouters.textContent = names.join('\n');
  }

  function renderMempoolStatus(){
    if (!mpWs || !mpRate || !mpFetch || !mpTriggers) return;
    const st = mempoolStatus || {};
    const connected = !!st.ws_connected;
    const wsLabel = connected ? 'connected' : 'offline';
    mpWs.textContent = wsLabel;
    mpWs.style.color = connected ? 'var(--good)' : 'var(--muted)';
    if (wsStatusBadge) {
      wsStatusBadge.textContent = connected ? 'ok' : 'offline';
      wsStatusBadge.style.color = connected ? 'var(--good)' : 'var(--bad)';
    }
    const rate = Number(st.tx_hash_rate || 0);
    mpRate.textContent = rate.toFixed(2);
    const fetchRate = Number(st.tx_fetch_success_rate || 0) * 100;
    mpFetch.textContent = Number.isFinite(fetchRate) ? fetchRate.toFixed(1) + '%' : '—';
    const queued = Number(st.triggers_queued || 0);
    const running = Number(st.triggers_running || 0);
    mpTriggers.textContent = `${queued}/${running}`;
    if (mpTotal) {
      const seen = Number(st.total_triggers_seen || 0);
      const processed = Number(st.total_triggers_processed || 0);
      mpTotal.textContent = `${seen}/${processed}`;
    }
    if (mpDropped) {
      const droppedQ = Number(st.total_triggers_dropped_queue || 0);
      const droppedTtl = Number(st.total_triggers_dropped_ttl || 0);
      mpDropped.textContent = `${droppedQ}/${droppedTtl}`;
    }
    if (mpLatency) {
      const lat = Number(st.avg_trigger_latency_ms || 0);
      mpLatency.textContent = Number.isFinite(lat) ? `${lat.toFixed(0)}ms` : '—';
    }
    if (mpDecoded) {
      const dec = Number(st.decoded_swaps_total || 0);
      mpDecoded.textContent = String(dec);
    }
    if (mpPersist) {
      const pers = Number(st.persistent_hits_total || 0);
      const total = Number(st.post_validations_total || 0);
      const warn = !!st.persistent_hit_warning;
      mpPersist.textContent = total > 0 ? `${pers}/${total}` : String(pers);
      mpPersist.style.color = warn ? 'var(--bad)' : 'var(--muted)';
    }
    if (lastBlockEl && st.current_block) {
      lastBlockEl.textContent = String(st.current_block);
    }
    updateWarnings();
    renderWatchedRouters();
  }

  function renderMempoolSwaps(){
    if (!mpSwaps) return;
    if (!mempoolSwaps.length) {
      mpSwaps.textContent = '—';
      return;
    }
    const lines = mempoolSwaps.slice(-10).map((s) => {
      const kind = s.kind || 'swap';
      const tin = s.token_in ? s.token_in.slice(0, 6) + '…' + s.token_in.slice(-4) : '?';
      const tout = s.token_out ? s.token_out.slice(0, 6) + '…' + s.token_out.slice(-4) : '?';
      const amt = (s.amount_in != null) ? String(s.amount_in) : '?';
      return `${kind} ${tin}->${tout} in=${amt}`;
    });
    mpSwaps.textContent = lines.join('\n');
  }

  function renderMempoolTriggers(){
    if (!mpTriggerScans) return;
    if (!mempoolTriggerScans.length) {
      mpTriggerScans.textContent = '—';
      return;
    }
    mpTriggerScans.textContent = '';
    mempoolTriggerScans.slice(-10).forEach((t) => {
      const row = document.createElement('div');
      row.className = 'row';
      const outcome = t.classification || t.outcome || 'no_hit';
      const net = Number(t.best_net || 0).toFixed(4);
      const hops = (t.hops != null) ? `h${t.hops}` : '';
      const backend = t.backend ? `@${t.backend}` : '';
      const dexMix = t.dex_mix ? JSON.stringify(t.dex_mix) : '';
      const route = t.best_route ? String(t.best_route) : '—';
      row.textContent = `${outcome} net=${net} ${hops}${backend} ${dexMix} ${route}`;
      row.addEventListener('click', () => {
        selectedTriggerDetail = t;
        renderTriggerDetail();
      });
      mpTriggerScans.appendChild(row);
    });
    const latest = mempoolTriggerScans[mempoolTriggerScans.length - 1];
    if (latest && mpLastOutcome) {
      mpLastOutcome.textContent = String(latest.classification || latest.outcome || '—');
    }
    if (latest && lastHitRoute) {
      lastHitRoute.textContent = latest.best_route ? String(latest.best_route) : '—';
    }
    if (latest && lastHitBackend) {
      lastHitBackend.textContent = latest.backend ? String(latest.backend) : '—';
    }
  }

  function pushMempoolSwap(entry){
    mempoolSwaps.push(entry);
    if (mempoolSwaps.length > 20) mempoolSwaps.shift();
    renderMempoolSwaps();
  }

  function pushMempoolTrigger(entry){
    mempoolTriggerScans.push(entry);
    if (mempoolTriggerScans.length > 20) mempoolTriggerScans.shift();
    if (entry && typeof entry.scheduled === 'number') {
      if (entry.scheduled === 0) triggerZeroStreak += 1;
      else triggerZeroStreak = 0;
    }
    renderMempoolTriggers();
    updateWarnings();
  }

  function renderTriggerDetail(){
    if (!mpDetail) return;
    if (!selectedTriggerDetail) {
      mpDetail.textContent = 'Select a trigger to view details.';
      return;
    }
    try {
      mpDetail.textContent = JSON.stringify(selectedTriggerDetail, null, 2);
    } catch {
      mpDetail.textContent = String(selectedTriggerDetail);
    }
  }

  function parseCsvList(value){
    if (Array.isArray(value)) return value.map((v) => String(v).trim()).filter((v) => v.length > 0);
    const text = String(value || '').trim();
    if (!text) return [];
    return text.split(',').map((v) => String(v).trim()).filter((v) => v.length > 0);
  }

  function parseCsvNumbers(value){
    return parseCsvList(value).map((v) => Number(v)).filter((v) => Number.isFinite(v));
  }

  function formatCsvList(value){
    if (Array.isArray(value)) return value.join(',');
    if (typeof value === 'string') return value;
    return '';
  }

  function parseRangeValue(value){
    if (Array.isArray(value) && value.length >= 2) {
      const min = Number(value[0]);
      const max = Number(value[1]);
      return {
        min: Number.isFinite(min) ? min : null,
        max: Number.isFinite(max) ? max : null,
      };
    }
    const text = String(value || '').trim();
    if (!text) return { min: null, max: null };
    if (text.includes('..')) {
      const parts = text.split('..').map((v) => v.trim());
      const min = Number(parts[0]);
      const max = Number(parts[1]);
      return {
        min: Number.isFinite(min) ? min : null,
        max: Number.isFinite(max) ? max : null,
      };
    }
    const n = Number(text);
    return { min: Number.isFinite(n) ? n : null, max: null };
  }

  function formatRangeValue(min, max){
    if (min == null && max == null) return '';
    const left = (min == null) ? '' : String(min);
    const right = (max == null) ? '' : String(max);
    return `${left}..${right}`;
  }

  function normalizePresetSettings(raw){
    if (!raw || typeof raw !== 'object') return {};
    const alias = {
      dex_adapters: 'dexes',
      enable_multidex_beam: 'enable_multidex',
      reporting_currency: 'report_currency',
      amounts: 'amount_presets',
      slippage_safety_bps: 'slippage_bps',
    };
    const out = {};
    Object.entries(raw).forEach(([key, value]) => {
      if (key === 'stage2_amount_range') {
        const parsed = parseRangeValue(value);
        if (parsed.min != null) out.stage2_amount_min = parsed.min;
        if (parsed.max != null) out.stage2_amount_max = parsed.max;
        return;
      }
      const mapped = alias[key] || key;
      if (mapped === 'dexes') {
        out[mapped] = parseCsvList(value);
        return;
      }
      if (mapped === 'amount_presets') {
        out[mapped] = parseCsvNumbers(value);
        return;
      }
      out[mapped] = value;
    });
    return out;
  }

  function currentTotalProfit(){
    return Number(totalProfitBySym[profitCurrency] || 0);
  }

  function setRunning(running){
    runBadge.textContent = running ? 'running' : 'stopped';
    runBadge.className = 'badge ' + (running ? 'good' : '');
    stateText.textContent = running ? 'running' : 'stopped';

    // Button logic you described:
    // - initial start disabled until connected
    // - when running: start disabled, stop enabled
    // - when stopped: start enabled, stop disabled
    if (running){
      startBtn.disabled = true;
      stopBtn.disabled = false;
      if (botStartedAtMs === null) botStartedAtMs = Date.now();
    } else {
      startBtn.disabled = !wsConnected;
      stopBtn.disabled = true;
      botStartedAtMs = null;
    }

    if (uptimeState) {
      uptimeState.textContent = running ? 'running' : 'stopped';
      uptimeState.className = 'badge ' + (running ? 'good' : '');
    }
  }

  function formatUptime(ms){
    const total = Math.max(0, Math.floor(ms / 1000));
    const hh = String(Math.floor(total / 3600)).padStart(2, '0');
    const mm = String(Math.floor((total % 3600) / 60)).padStart(2, '0');
    const ss = String(total % 60).padStart(2, '0');
    return `${hh}:${mm}:${ss}`;
  }

  // Update uptime ticker (top-right)
  setInterval(() => {
    if (!uptimeText) return;
    if (botStartedAtMs == null){
      uptimeText.textContent = '00:00:00';
      return;
    }
    uptimeText.textContent = formatUptime(Date.now() - Number(botStartedAtMs));
  }, 1000);

  function schedulePersist(){
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(persistState, 400);
  }

  function sendStateToServer(state){
    try {
      fetch('/ui_state', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ state: state || {} }),
      }).catch(()=>{});
    } catch (e) {
      // ignore server sync failures
    }
  }

  function persistState(){
    try {
      const savedAtMs = Date.now();
      const state = {
        v: 3,
        saved_at_ms: savedAtMs,
        logs: logItems.slice(-MAX_LOGS),
        profitEvents: profitEvents.slice(-MAX_PROFITS),
        blocksScanned: blocksScanned,
        lastCountedBlock: lastCountedBlock,
        profitableHits: profitableHits,
        rawOpps: rawOpps,
        safetyOpps: safetyOpps,
        gasOpps: gasOpps,
        readyOpps: readyOpps,
        sanityRejectsTotal: sanityRejectsTotal,
        rejectsByReason: { ...rejectsByReason },
        profitCurrency: profitCurrency,
        totalProfitBySym: { ...totalProfitBySym },
        totalSpentBySym: { ...totalSpentBySym },
        lastBlock: lastBlockEl ? lastBlockEl.textContent : null,
        notice: {
          kind: opBadge ? opBadge.textContent : '',
          text: noticeText ? noticeText.textContent : '',
        },
      };
      lastSavedAtMs = savedAtMs;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      sendStateToServer(state);
    } catch (e) {
      // ignore storage failures
    }
  }

  function clearObject(obj){
    Object.keys(obj).forEach((k) => { delete obj[k]; });
  }

  function normalizeProfitEvent(evt){
    if (!evt || typeof evt !== 'object') return null;
    const profit = (evt.profit != null && Number.isFinite(Number(evt.profit))) ? Number(evt.profit) : null;
    const spent = (evt.spent != null && Number.isFinite(Number(evt.spent))) ? Number(evt.spent) : null;
    const roi = (evt.roi_pct != null && Number.isFinite(Number(evt.roi_pct))) ? Number(evt.roi_pct) : null;
    return {
      t: (evt.t != null) ? String(evt.t) : '',
      block: (typeof evt.block === 'number') ? evt.block : null,
      profit: profit,
      sym: (typeof evt.sym === 'string') ? evt.sym.toUpperCase() : null,
      route: (typeof evt.route === 'string') ? evt.route : (typeof evt.route_full === 'string') ? evt.route_full : '—',
      spent: spent,
      spent_sym: (typeof evt.spent_sym === 'string') ? evt.spent_sym.toUpperCase() : (typeof evt.token_in_sym === 'string') ? evt.token_in_sym.toUpperCase() : null,
      roi_pct: roi,
      route_short: (typeof evt.route_short === 'string') ? evt.route_short : null,
      route_full: (typeof evt.route_full === 'string') ? evt.route_full : null,
    };
  }

  function computeTotalsFromEvents(){
    const profitBySym = {};
    const spentBySym = {};
    let hits = 0;
    profitEvents.forEach((evt) => {
      if (!evt || typeof evt !== 'object') return;
      const sym = String(evt.sym || profitCurrency || 'USDC').toUpperCase();
      if (evt.profit != null && Number.isFinite(Number(evt.profit))){
        profitBySym[sym] = Number(profitBySym[sym] || 0) + Number(evt.profit);
        hits += 1;
      }
      if (evt.spent != null && Number.isFinite(Number(evt.spent))){
        spentBySym[sym] = Number(spentBySym[sym] || 0) + Number(evt.spent);
      }
    });
    return { profitBySym, spentBySym, hits };
  }

  function rebuildTotalsFromEvents(){
    const totals = computeTotalsFromEvents();
    clearObject(totalProfitBySym);
    clearObject(totalSpentBySym);
    Object.assign(totalProfitBySym, totals.profitBySym);
    Object.assign(totalSpentBySym, totals.spentBySym);
    profitableHits = totals.hits;
  }

  function rebuildProfitTable(){
    if (!profitRows) return;
    profitRows.textContent = '';
    const list = profitEvents.slice(-10);
    for (let i = list.length - 1; i >= 0; i--){
      const row = renderProfitRow(list[i]);
      if (row) profitRows.appendChild(row);
    }
  }

  function restoreStateFromData(state){
    if (!state || typeof state !== 'object') return false;
    const savedAt = (typeof state.saved_at_ms === 'number') ? state.saved_at_ms : 0;
    if (lastSavedAtMs && savedAt === 0) return false;
    if (savedAt && savedAt < lastSavedAtMs) return false;
    if (savedAt) lastSavedAtMs = savedAt;

    if (Array.isArray(state.logs)){
      logItems.length = 0;
      if (logsDiv) logsDiv.textContent = '';
      state.logs.slice(-MAX_LOGS).forEach((entry) => {
        const e = {
          type: (entry && typeof entry.type === 'string') ? entry.type : 'log',
          time: (entry && entry.time != null) ? String(entry.time) : '',
          block: (entry && typeof entry.block === 'number') ? entry.block : null,
          text: (entry && entry.text != null) ? String(entry.text) : '',
          meta: (entry && entry.meta && typeof entry.meta === 'object') ? entry.meta : null,
        };
        logItems.push(e);
        renderLogEntry(e);
      });
      logs = logItems.length;
      if (logCount) logCount.textContent = String(logs);
    }

    if (typeof state.blocksScanned === 'number' && Number.isFinite(state.blocksScanned)){
      blocksScanned = state.blocksScanned;
    }
    if (state.lastCountedBlock !== undefined && state.lastCountedBlock !== null){
      const lb = Number(state.lastCountedBlock);
      if (Number.isFinite(lb)) lastCountedBlock = lb;
    }
    if (typeof state.rawOpps === 'number' && Number.isFinite(state.rawOpps)){
      rawOpps = state.rawOpps;
    }
    if (typeof state.safetyOpps === 'number' && Number.isFinite(state.safetyOpps)){
      safetyOpps = state.safetyOpps;
    }
    if (typeof state.gasOpps === 'number' && Number.isFinite(state.gasOpps)){
      gasOpps = state.gasOpps;
    }
    if (typeof state.readyOpps === 'number' && Number.isFinite(state.readyOpps)){
      readyOpps = state.readyOpps;
    }
    if (typeof state.sanityRejectsTotal === 'number' && Number.isFinite(state.sanityRejectsTotal)){
      sanityRejectsTotal = state.sanityRejectsTotal;
    }
    if (state.rejectsByReason && typeof state.rejectsByReason === 'object'){
      clearObject(rejectsByReason);
      Object.entries(state.rejectsByReason).forEach(([k, v]) => {
        const n = Number(v);
        if (Number.isFinite(n)) rejectsByReason[String(k)] = n;
      });
    }

    if (typeof state.profitCurrency === 'string' && state.profitCurrency.trim()){
      profitCurrency = state.profitCurrency.trim().toUpperCase();
    }

    if (lastBlockEl && state.lastBlock != null){
      lastBlockEl.textContent = String(state.lastBlock);
      if (lastCountedBlock === null || lastCountedBlock === undefined){
        const lb = Number(state.lastBlock);
        if (Number.isFinite(lb)) lastCountedBlock = lb;
      }
    }

    if (state.notice && typeof state.notice === 'object'){
      const kind = (typeof state.notice.kind === 'string') ? state.notice.kind : 'status';
      const text = (typeof state.notice.text === 'string') ? state.notice.text : '';
      setNotice(kind, text);
    }

    if (Array.isArray(state.profitEvents)){
      profitEvents.length = 0;
      state.profitEvents.slice(-MAX_PROFITS).forEach((evt) => {
        const norm = normalizeProfitEvent(evt);
        if (norm) profitEvents.push(norm);
      });
    }

    const hasProfitTotals = (state.totalProfitBySym && typeof state.totalProfitBySym === 'object');
    const hasSpentTotals = (state.totalSpentBySym && typeof state.totalSpentBySym === 'object');
    if (hasProfitTotals){
      clearObject(totalProfitBySym);
      Object.entries(state.totalProfitBySym).forEach(([k, v]) => {
        const n = Number(v);
        if (Number.isFinite(n)) totalProfitBySym[String(k).toUpperCase()] = n;
      });
    }
    if (hasSpentTotals){
      clearObject(totalSpentBySym);
      Object.entries(state.totalSpentBySym).forEach(([k, v]) => {
        const n = Number(v);
        if (Number.isFinite(n)) totalSpentBySym[String(k).toUpperCase()] = n;
      });
    }

    if (typeof state.profitableHits === 'number' && Number.isFinite(state.profitableHits)){
      profitableHits = state.profitableHits;
    } else if (!hasProfitTotals && !hasSpentTotals) {
      rebuildTotalsFromEvents();
    } else if (!hasProfitTotals || !hasSpentTotals) {
      const totals = computeTotalsFromEvents();
      if (!hasProfitTotals){
        clearObject(totalProfitBySym);
        Object.assign(totalProfitBySym, totals.profitBySym);
      }
      if (!hasSpentTotals){
        clearObject(totalSpentBySym);
        Object.assign(totalSpentBySym, totals.spentBySym);
      }
      if (!Number.isFinite(state.profitableHits)) profitableHits = totals.hits;
    }

    rebuildProfitTable();
    drawChart();
    updateStats();
    return true;
  }

  function restoreState(){
    let raw = null;
    try { raw = localStorage.getItem(STORAGE_KEY); } catch { return false; }
    if (!raw) return false;
    let state;
    try { state = JSON.parse(raw); } catch { return false; }
    return restoreStateFromData(state);
  }

  function fetchServerState(){
    fetch('/ui_state')
      .then((r) => r.json())
      .then((out) => {
        if (out && out.ok && out.state) restoreStateFromData(out.state);
      })
      .catch(()=>{});
  }

  function renderLogEntry({type, time, block, text}){

    const item = document.createElement('div');
    item.className = 'logItem';

    const badge = document.createElement('span');
    badge.className = 'badge';
    if (type === 'profit') badge.classList.add('good');
    if (type === 'warn' || type === 'stderr') badge.classList.add('warn');
    if (type === 'status') badge.classList.add('blue');

    badge.textContent = type || 'log';

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.appendChild(Object.assign(document.createElement('span'), {textContent: time || ''}));

    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.gap = '8px';
    right.style.alignItems = 'center';
    if (typeof block === 'number'){
      const b = document.createElement('span');
      b.className = 'badge blue';
      b.textContent = 'Block ' + block;
      right.appendChild(b);
    }
    right.appendChild(badge);
    meta.appendChild(right);

    const body = document.createElement('div');
    body.className = 'text';
    body.textContent = text || '';

    item.appendChild(meta);
    item.appendChild(body);

    // If user is already near the bottom, keep auto-scrolling like a terminal.
    const nearBottom = (logsDiv.scrollTop + logsDiv.clientHeight) >= (logsDiv.scrollHeight - 40);

    // Newest logs go to the bottom (terminal-style)
    logsDiv.appendChild(item);

    // Keep feed lightweight (remove oldest from the top)
    while (logsDiv.children.length > MAX_LOGS){
      logsDiv.removeChild(logsDiv.firstChild);
    }

    if (nearBottom){
      logsDiv.scrollTop = logsDiv.scrollHeight;
    }
  }

  function addLog(msg){
    const payload = (msg && typeof msg === 'object') ? msg : {};
    const type = payload.type;
    const time = payload.time;
    const block = payload.block;
    const text = payload.text;
    const meta = Object.assign({}, payload);
    delete meta.type;
    delete meta.time;
    delete meta.block;
    delete meta.text;
    const entry = {
      type: type || 'log',
      time: time || '',
      block: block ?? null,
      text: text || '',
      meta: Object.keys(meta).length ? meta : null,
    };
    logItems.push(entry);
    if (logItems.length > MAX_LOGS) logItems.shift();
    renderLogEntry(entry);
    while (logsDiv.children.length > MAX_LOGS){
      logsDiv.removeChild(logsDiv.firstChild);
    }
    logs = logItems.length;
    logCount.textContent = String(logs);
    schedulePersist();
  }

  function setNotice(kind, msg){
    noticeText.textContent = msg;
    opBadge.textContent = kind;
    opBadge.className = 'badge ' + (kind === 'profit' ? 'good' : kind === 'warn' ? 'warn' : '');

    // Icon + subtle color cue
    if (noticeIcon){
      if (kind === 'profit') noticeIcon.textContent = '✅';
      else if (kind === 'scan') noticeIcon.textContent = '🔍';
      else if (kind === 'warn') noticeIcon.textContent = '⚠';
      else noticeIcon.textContent = 'ℹ';
      noticeIcon.className = 'badge ' + (kind === 'profit' ? 'good' : kind === 'warn' ? 'warn' : kind === 'scan' ? 'blue' : '');
    }

    schedulePersist();
  }

  function updateStats(){
    statBlocks.textContent = String(blocksScanned);
    statHits.textContent = String(profitableHits);
    const sym = profitCurrency || 'USDC';
    let v = Number(totalProfitBySym[sym] || 0);
    if (!Number.isFinite(v) || Math.abs(v) > 1e6) v = 0;
    statProfit.textContent = formatToken(v, 3) + ' ' + sym;

    let spent = Number(totalSpentBySym[sym] || 0);
    if (!Number.isFinite(spent) || Math.abs(spent) > 1e8) spent = 0;
    if (statSpent) statSpent.textContent = formatToken(spent, 3) + ' ' + sym;

    // Avg ROI across successful hits in the currently shown currency
    const roi = (spent > 0) ? (v / spent) * 100 : null;
    if (statRoi) statRoi.textContent = (roi == null || !Number.isFinite(roi) || Math.abs(roi) > 1e6) ? '—' : formatPct(roi, 2);

    const fmtOpp = (count) => {
      const c = Number(count || 0);
      if (!Number.isFinite(c)) return '0';
      if (blocksScanned > 0) {
        const per = c / blocksScanned;
        return `${Math.round(c)} (${per.toFixed(3)}/blk)`;
      }
      return String(Math.round(c));
    };
    if (statRaw) statRaw.textContent = fmtOpp(rawOpps);
    if (statSafety) statSafety.textContent = fmtOpp(safetyOpps);
    if (statGas) statGas.textContent = fmtOpp(gasOpps);
    if (statReady) statReady.textContent = fmtOpp(readyOpps);
  }

  function initCollapsibles(){
    document.querySelectorAll('.sectionCard[data-section]').forEach((el) => {
      const key = `section:${el.dataset.section}`;
      const saved = localStorage.getItem(key);
      if (saved === '1' || saved === '0') el.open = saved === '1';
      el.addEventListener('toggle', () => {
        localStorage.setItem(key, el.open ? '1' : '0');
      });
    });
    document.querySelectorAll('.advancedToggle[data-advanced]').forEach((el) => {
      const key = `advanced:${el.dataset.advanced}`;
      const saved = localStorage.getItem(key);
      if (saved === '1' || saved === '0') el.open = saved === '1';
      el.addEventListener('toggle', () => {
        localStorage.setItem(key, el.open ? '1' : '0');
      });
    });
  }

  function initSettingsSearch(){
    if (!settingsSearch) return;
    const fields = Array.from(document.querySelectorAll('.settingsPanel .field'));
    fields.forEach((f) => {
      const label = f.querySelector('label');
      const hint = f.querySelector('small');
      const labelText = label ? label.textContent : '';
      const hintText = hint ? hint.textContent : '';
      const input = f.querySelector('input, select, textarea');
      const inputId = input ? input.id : '';
      f.dataset.searchText = `${labelText} ${hintText} ${inputId}`.toLowerCase();
    });
    const apply = () => {
      const q = String(settingsSearch.value || '').trim().toLowerCase();
      fields.forEach((f) => {
        const text = f.dataset.searchText || '';
        if (!q) {
          f.classList.remove('hidden');
          f.classList.remove('match');
          return;
        }
        const match = text.includes(q);
        f.classList.toggle('hidden', !match);
        f.classList.toggle('match', match);
        if (match) {
          const section = f.closest('.sectionCard');
          if (section) section.open = true;
          const adv = f.closest('.advancedToggle');
          if (adv) adv.open = true;
        }
      });
    };
    settingsSearch.addEventListener('input', apply);
    if (settingsSearchClear) {
      settingsSearchClear.addEventListener('click', () => {
        settingsSearch.value = '';
        apply();
      });
    }
  }

  function applyQuickProfile(kind){
    const base = cfgFromForm();
    const patch = {};
    if (kind === 'debug') {
      patch.gas_off = true;
      patch.slippage_bps = 0;
      patch.mev_buffer_bps = 0;
      patch.mempool_trigger_scan_budget_s = 2.5;
      patch.trigger_prefer_cross_dex = true;
      patch.trigger_require_cross_dex = false;
    } else if (kind === 'cross_dex') {
      patch.trigger_prefer_cross_dex = true;
      patch.trigger_require_cross_dex = false;
      patch.edge_top_m = 3;
      patch.beam_k = 16;
      patch.mempool_trigger_scan_budget_s = 3.0;
    } else if (kind === 'strict') {
      patch.gas_off = false;
      patch.slippage_bps = 5;
      patch.mev_buffer_bps = 10;
      patch.min_profit_abs = 1;
      patch.min_profit_pct = 0.02;
      patch.max_gas_gwei = 50;
      patch.trigger_require_cross_dex = false;
    }
    fillForm({ ...base, ...patch });
    setNotice('status', `Recommended applied: ${kind.replace('_',' ')}`);
  }

  function parseProfitText(text){
    // fallback parser (older bot versions)
    const mProfit = text.match(/profit\s*=\s*([0-9.+-eE]+)/i);
    const mSpent = text.match(/(?:amount_in|spent|input)\s*=\s*([0-9.+-eE]+)/i);
    const mPct = text.match(/(?:profit_pct|roi|pct)\s*=\s*([0-9.+-eE]+)/i);
    const mSym = text.match(/(?:symbol|token|base)\s*=\s*([A-Z]{3,6})/);
    const mRoute = text.match(/route\s*=\s*(.+?)(?:\s+gas=|$)/i);
    const profit = mProfit ? Number(mProfit[1]) : null;
    const spent = mSpent ? Number(mSpent[1]) : null;
    const profit_pct = mPct ? Number(mPct[1]) : null;
    const route = mRoute ? String(mRoute[1]).trim() : '—';
    const sym = mSym ? String(mSym[1]) : null;
    return { profit, spent, profit_pct, sym, route };
  }

  function renderProfitRow(evt){
    if (!evt) return null;
    const row = document.createElement('div');
    row.className = 'row';

    const c1 = document.createElement('div');
    c1.className = 'mono';
    c1.textContent = evt.t || '';

    const c2 = document.createElement('div');
    c2.className = 'routeCell';
    const sc = document.createElement('div');
    sc.className = 'scroll mono';

    // Collapsible route (summary stays compact; full route available on demand)
    const det = document.createElement('details');
    const sum = document.createElement('summary');
    sum.textContent = summarizeRoute(evt.route || '—');
    const full = document.createElement('div');
    full.className = 'full mono';
    full.textContent = evt.route || '—';
    det.appendChild(sum);
    det.appendChild(full);
    sc.appendChild(det);

    // Allow horizontal scroll with mouse wheel when route overflows
    sc.addEventListener('wheel', (e) => {
      if (sc.scrollWidth > sc.clientWidth){
        sc.scrollLeft += e.deltaY;
        e.preventDefault();
      }
    }, { passive: false });

    c2.appendChild(sc);

    const c3 = document.createElement('div');
    c3.className = 'mono';
    c3.style.textAlign = 'right';
    const spentSym = evt.spent_sym || evt.token_in_sym || 'USDT';
    c3.textContent = (evt.spent == null) ? '—' : (formatToken(evt.spent, 3) + ' ' + spentSym);

    const c4 = document.createElement('div');
    c4.className = 'mono';
    c4.style.textAlign = 'right';
    c4.textContent = (evt.roi_pct == null) ? '—' : formatPct(evt.roi_pct, 2);

    const c5 = document.createElement('div');
    c5.className = 'mono';
    c5.style.textAlign = 'right';
    c5.textContent = formatToken(evt.profit || 0, 3) + ' ' + (evt.sym || profitCurrency);

    row.appendChild(c1);
    row.appendChild(c2);
    row.appendChild(c3);
    row.appendChild(c4);
    row.appendChild(c5);
    return row;
  }

  function pushProfitRow(evt){
    if (!profitRows) return;
    const row = renderProfitRow(evt);
    if (!row) return;
    // newest at top
    profitRows.prepend(row);
    while (profitRows.children.length > 10){
      profitRows.removeChild(profitRows.lastChild);
    }
  }

  function summarizeRoute(route){
    const r = String(route || '');
    if (r.length <= 42) return r;
    return r.slice(0, 24) + '…' + r.slice(-14);
  }

  function drawChart(){
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0,0,w,h);

    // axes background grid
    ctx.globalAlpha = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    for (let i=1;i<=4;i++){
      const y = Math.round((h*i)/5);
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(w,y);
      ctx.stroke();
    }

    const data = profitEvents.filter(e => (e.sym || profitCurrency) === profitCurrency).slice(-30);
    if (data.length === 0){
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.font = '700 14px ui-sans-serif, system-ui';
      ctx.fillText('Profit timeline will appear here after first hit', 16, 28);
      return;
    }

    const maxP = Math.max(...data.map(d=>d.profit), 1e-9);
    const minP = 0;

    const padX = 14;
    const padY = 18;

    const xStep = (w - padX*2) / Math.max(1, data.length-1);

    // line
    ctx.strokeStyle = 'rgba(68,194,119,0.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
      const x = padX + i*xStep;
      const y = h - padY - ((d.profit - minP) / (maxP - minP || 1)) * (h - padY*2);
      if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // points
    ctx.fillStyle = 'rgba(68,194,119,0.95)';
    data.forEach((d, i)=>{
      const x = padX + i*xStep;
      const y = h - padY - ((d.profit - minP) / (maxP - minP || 1)) * (h - padY*2);
      ctx.beginPath();
      ctx.arc(x,y,3.3,0,Math.PI*2);
      ctx.fill();
    });

    // label max
    ctx.fillStyle = 'rgba(255,255,255,0.70)';
    ctx.font = '700 12px ui-monospace, monospace';
	    ctx.fillText('max ' + formatToken(maxP, 3) + ' ' + (profitCurrency || ''), 16, h-10);
  }

  // -----------------------------
  // WebSocket
  let ws = null;
  let wsConnected = false;

  function setConn(state){
    wsConnected = state;
    connDot.className = 'dot ' + (state ? 'ok' : 'off');
    connText.textContent = state ? 'online' : 'offline';

    // enable start only when connected AND not running
    if (!state){
      startBtn.disabled = true;
      stopBtn.disabled = true;
    } else {
      // sync status from server
      fetch('/status').then(r=>r.json()).then(s=>{
        if (s && s.ok) {
          if (typeof s.started_at_ms === 'number') botStartedAtMs = s.started_at_ms;
          setRunning(!!s.running);
        }
        else setRunning(false);
      }).catch(()=>setRunning(false));
    }
  }

  function connectWS(){
    ws = new WebSocket(`ws://${location.host}`);

    ws.onopen = () => {
      setConn(true);
      addLog({type:'status', time: new Date().toISOString().slice(11,19), block:null, text:'UI connected'});
    };

    ws.onmessage = (event) => {
      let msg;
      try { msg = JSON.parse(event.data); } catch { return; }

      // unified log
      addLog(msg);

      // Reset runtime UI state (sent by UI server on /restart) to avoid showing stale RPC pool
      if (msg.type === 'reset') {
        blocksScanned = 0;
        lastCountedBlock = null;
        profitableHits = 0;
        rawOpps = 0;
        safetyOpps = 0;
        gasOpps = 0;
        readyOpps = 0;
        sanityRejectsTotal = 0;
        clearObject(rejectsByReason);
        clearObject(totalProfitBySym);
        clearObject(totalSpentBySym);
        profitEvents.length = 0;
        mempoolSwaps.length = 0;
        mempoolTriggerScans.length = 0;
        mempoolStatus = null;
        selectedTriggerDetail = null;
        if (profitRows) profitRows.textContent = '';
        if (rpcStatsBody) rpcStatsBody.textContent = '—';
        if (rpcStatusBadge) {
          rpcStatusBadge.textContent = '—';
          rpcStatusBadge.style.color = 'var(--muted)';
        }
        if (wsStatusBadge) {
          wsStatusBadge.textContent = '—';
          wsStatusBadge.style.color = 'var(--muted)';
        }
        renderMempoolSwaps();
        renderMempoolTriggers();
        if (mpDetail) mpDetail.textContent = 'Select a trigger to view details.';
        drawChart();
        updateStats();
        setNotice('status', msg.text || 'restarting...');
        return;
      }

      if (msg.type === 'status'){
        if (typeof msg.started_at_ms === 'number') botStartedAtMs = msg.started_at_ms;
        if (msg.started_at_ms === null) botStartedAtMs = null;
        if (typeof msg.running === 'boolean') setRunning(msg.running);
        if (typeof msg.text === 'string' && msg.text.toLowerCase().includes('stopped')) setRunning(false);
        if (typeof msg.text === 'string' && msg.text.toLowerCase().includes('started')) setRunning(true);
        // Status is for process/network state, not for scan results
        setNotice('status', msg.text || 'status');
      }

      if (msg.type === 'scan'){
        if (typeof msg.block === 'number'){
          lastBlockEl.textContent = String(msg.block);
          const isResult = (
            typeof msg.raw_opps === 'number' ||
            typeof msg.candidates === 'number' ||
            typeof msg.profitable === 'number' ||
            typeof msg.best_profit === 'number'
          );
          if (isResult && msg.block !== lastCountedBlock){
            blocksScanned += 1;
            lastCountedBlock = msg.block;
          }
          if (typeof msg.raw_opps === 'number') rawOpps += msg.raw_opps;
          if (typeof msg.safety_opps === 'number') safetyOpps += msg.safety_opps;
          if (typeof msg.gas_opps === 'number') gasOpps += msg.gas_opps;
          if (typeof msg.final_opps === 'number') readyOpps += msg.final_opps;
          if (typeof msg.sanity_rejects_total === 'number') sanityRejectsTotal += msg.sanity_rejects_total;
          if (msg.rejects_by_reason && typeof msg.rejects_by_reason === 'object'){
            Object.entries(msg.rejects_by_reason).forEach(([k, v]) => {
              const n = Number(v);
              if (Number.isFinite(n)) rejectsByReason[String(k)] = Number(rejectsByReason[String(k)] || 0) + n;
            });
          }
          updateStats();
          const candidates = (typeof msg.candidates === 'number') ? msg.candidates : null;
          const profitable = (typeof msg.profitable === 'number') ? msg.profitable : null;
          const best = (typeof msg.best_profit === 'number') ? msg.best_profit : null;

          let summary = msg.text || '';
          if (!summary){
            summary = 'Scan complete';
            if (candidates != null) summary += ` | routes=${candidates}`;
            if (profitable != null) summary += ` | profitable=${profitable}`;
            if (best != null) summary += ` | best=${best.toFixed(6)}`;
          }
          setNotice('scan', summary);
        }
      }

      if (msg.type === 'warn'){
        if (typeof msg.block === 'number') lastBlockEl.textContent = String(msg.block);
        setNotice('warn', msg.text || 'warning');
      }

      if (msg.type === 'rpc_stats'){
        if (rpcStatsBody && Array.isArray(msg.stats)){
          // Render compact: url host | ok/fail | inflight | latency
          const lines = msg.stats.map((s) => {
            const url = String(s.url || '');
            let host = url;
            try { host = (new URL(url)).host; } catch {}
            const ok = Number(s.ok || 0);
            const fail = Number(s.fail || 0);
            const inflight = Number(s.inflight || 0);
            const lat = (typeof s.lat_ms === 'number') ? s.lat_ms : Number(s.lat_ms || 0);
            const weight = (typeof s.weight === 'number') ? s.weight : Number(s.weight || 0);
            const cb = s.cb_open ? 'cb=on' : 'cb=off';
            const fb = s.fallback_only ? 'fb=1' : 'fb=0';
            return `${host.padEnd(24, ' ')} w=${weight} ${fb} ${cb} ok=${ok} fail=${fail} in=${inflight} lat=${lat}ms`;
          });
          rpcStatsBody.textContent = lines.join('\n') || '—';
        }
        lastRpcStatsAt = Date.now();
        if (rpcStatusBadge) {
          rpcStatusBadge.textContent = 'ok';
          rpcStatusBadge.style.color = 'var(--good)';
        }
      }

      if (msg.type === 'mempool_status'){
        mempoolStatus = msg;
        renderMempoolStatus();
      }

      if (msg.type === 'mempool_swap'){
        pushMempoolSwap(msg);
      }

      if (msg.type === 'trigger_scan'){
        pushMempoolTrigger(msg);
      }

      if (msg.type === 'profit'){
        if (typeof msg.block === 'number') lastBlockEl.textContent = String(msg.block);
        // Prefer structured fields from the bot; fall back to parsing text.
        const parsed = parseProfitText(msg.text || '');
        const profit = (typeof msg.profit === 'number') ? msg.profit : parsed.profit;
        const route = (typeof msg.route === 'string') ? msg.route : parsed.route;
        const symFromMsg = (typeof msg.profit_symbol === 'string') ? msg.profit_symbol : (parsed.sym || null);
        // Optional extra fields (newer bot builds may send these)
        const spent = (typeof msg.spent === 'number') ? msg.spent
          : (typeof msg.amount_in_display === 'number') ? msg.amount_in_display
          : (typeof msg.amount_in === 'number') ? msg.amount_in
          : parsed.spent;
        const spentSym = (typeof msg.spent_symbol === 'string') ? msg.spent_symbol
          : (typeof msg.token_in_symbol === 'string') ? msg.token_in_symbol
          : 'USDT';
        const roiPct = (typeof msg.roi_pct === 'number') ? msg.roi_pct
          : (typeof msg.profit_pct === 'number') ? msg.profit_pct
          : (parsed.profit_pct != null && isFinite(parsed.profit_pct)) ? parsed.profit_pct
          : (spent != null && isFinite(spent) && spent !== 0 && profit != null && isFinite(profit)) ? (Number(profit) / Number(spent) * 100) : null;
        const profitOk = (profit != null && Number.isFinite(profit) && Math.abs(Number(profit)) < 1e6);
        const spentOk = (spent != null && Number.isFinite(spent) && Number(spent) > 0 && Math.abs(Number(spent)) < 1e8);
        if (profitOk){
          profitableHits += 1;
          const sym = (symFromMsg || spentSym || profitCurrency || 'USDC').toUpperCase();
          // The panel is single-currency. If the bot ever sends a different symbol,
          // we ignore it and warn instead of mixing numbers with the wrong label.
          if (sym !== profitCurrency) {
            console.warn('Ignoring profit event with different currency', {sym, profitCurrency, msg});
            addLog({ type: 'warn', time: msg.time || new Date().toISOString().slice(11,19), block: msg.block, text: `Ignored profit in ${sym} (panel currency is ${profitCurrency})` });
            return;
          }
          totalProfitBySym[sym] = Number(totalProfitBySym[sym] || 0) + Number(profit);

          // Track total spent in the input token (usually same as profit token for this scanner).
          if (spentOk){
            totalSpentBySym[sym] = Number(totalSpentBySym[sym] || 0) + Number(spent);
          }
          updateStats();
          const evt = {
            t: msg.time || new Date().toISOString().slice(11,19),
            block: msg.block,
            profit: profit,
            sym: sym,
            route: route,
            spent: spent,
            spent_sym: spentSym,
            roi_pct: roiPct,
            route_short: (typeof msg.route_short === 'string') ? msg.route_short : route,
            route_full: (typeof msg.route_full === 'string') ? msg.route_full : route,
          };
          profitEvents.push(evt);
          if (profitEvents.length > MAX_PROFITS) profitEvents.shift();
          drawChart();
          pushProfitRow(evt);
          setNotice('profit', '✅ Profitable opportunity found');
        } else {
          setNotice('profit', msg.text || 'profit');
        }
      }
    };

    ws.onclose = () => {
      setConn(false);
      addLog({type:'status', time: new Date().toISOString().slice(11,19), block:null, text:'Connection closed. Reconnecting...'});
      setNotice('warn', 'Connection closed. Reconnecting...');
      setTimeout(connectWS, 700);
    };

    ws.onerror = () => {
      // close will handle
    };
  }

  // -----------------------------
  // Controls
  async function post(path){
    const r = await fetch(path, {method:'POST'});
    return r.json().catch(()=>({ok:false}));
  }

  async function getConfig(){
    return fetch('/config').then(r=>r.json()).catch(()=>({ok:false}));
  }

  async function saveConfig(cfg){
    const r = await fetch('/config', {
      method:'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify(cfg || {}),
    });
    return r.json().catch(()=>({ok:false}));
  }

  async function fetchMempoolStatus(){
    return fetch('/api/mempool/status').then((r)=>r.json()).catch(()=>({ok:false}));
  }

  async function fetchMempoolRecent(){
    return fetch('/api/mempool/recent').then((r)=>r.json()).catch(()=>({ok:false}));
  }

  async function fetchMempoolTriggers(){
    return fetch('/api/mempool/triggers').then((r)=>r.json()).catch(()=>({ok:false}));
  }

  async function refreshMempoolPanels(){
    const [s, r, t] = await Promise.all([fetchMempoolStatus(), fetchMempoolRecent(), fetchMempoolTriggers()]);
    if (s && s.ok) {
      mempoolStatus = s.status || null;
      renderMempoolStatus();
    }
    if (r && r.ok && Array.isArray(r.recent)) {
      mempoolSwaps.length = 0;
      r.recent.forEach((x) => mempoolSwaps.push(x));
      renderMempoolSwaps();
    }
    if (t && t.ok && Array.isArray(t.triggers)) {
      mempoolTriggerScans.length = 0;
      t.triggers.forEach((x) => mempoolTriggerScans.push(x));
      renderMempoolTriggers();
    }
  }

  async function fetchPresetIndex(){
    return fetch('/api/presets').then((r)=>r.json()).catch(()=>({ok:false}));
  }

  async function fetchPresetById(id){
    return fetch(`/api/presets/${encodeURIComponent(id)}`).then((r)=>r.json()).catch(()=>({ok:false}));
  }

  const presetById = {};

  async function loadPresetIndex(){
    if (!cfgPreset) return;
    const out = await fetchPresetIndex();
    if (!out || !out.ok || !Array.isArray(out.presets)) return;
    Object.keys(presetById).forEach((k) => { delete presetById[k]; });
    cfgPreset.textContent = '';
    const empty = document.createElement('option');
    empty.value = '';
    empty.textContent = '— select preset —';
    cfgPreset.appendChild(empty);
    out.presets.forEach((p) => {
      if (!p || typeof p !== 'object') return;
      const id = String(p.id || '').trim();
      if (!id) return;
      presetById[id] = p;
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = String(p.name || id);
      cfgPreset.appendChild(opt);
    });
    if (cfgPresetDesc) cfgPresetDesc.textContent = 'Select a preset to populate the fields below.';
  }

  function updatePresetDesc(){
    if (!cfgPresetDesc || !cfgPreset) return;
    const id = String(cfgPreset.value || '');
    if (!id) {
      cfgPresetDesc.textContent = 'Select a preset to populate the fields below.';
      updateHeaderBadges();
      return;
    }
    const p = presetById[id];
    cfgPresetDesc.textContent = (p && p.description) ? String(p.description) : 'Preset loaded.';
    updateHeaderBadges();
  }

  async function applyPresetSelection(){
    if (!cfgPreset) return;
    const id = String(cfgPreset.value || '').trim();
    if (!id) {
      setNotice('warn', 'Select a preset first');
      return;
    }
    const out = await fetchPresetById(id);
    if (!out || !out.ok || !out.preset) {
      setNotice('warn', 'Preset load failed');
      return;
    }
    const preset = out.preset || {};
    const normalized = normalizePresetSettings(preset.settings || {});
    const merged = { ...cfgFromForm(), ...normalized };
    fillForm(merged);
    setNotice('status', `Preset applied: ${String(preset.name || id)}`);
    updateHeaderBadges();
  }

  function cfgFromForm(){
    // range parsing: "min..max"
    const range = parseRangeValue(cfgRange.value);
    return {
      rpc_urls: String(cfgRpcUrls?.value || '').trim(),
      dexes: String(cfgDexes?.value || '').trim(),
      enable_multidex: !!cfgEnableMultidex?.checked,
      trigger_prefer_cross_dex: !!cfgTriggerPreferCrossDex?.checked,
      trigger_require_cross_dex: !!cfgTriggerRequireCrossDex?.checked,
      trigger_cross_dex_fallback: !!cfgTriggerCrossDexFallback?.checked,
      trigger_require_three_hops: !!cfgTriggerRequire3Hops?.checked,
      trigger_base_fallback_enabled: !!cfgTriggerBaseFallback?.checked,
      trigger_allow_two_hop_fallback: !!cfgTriggerAllowTwoHop?.checked,
      trigger_connectors: String(cfgTriggerConnectors?.value || '').trim(),
      trigger_max_candidates_raw: parseInt(cfgTriggerMaxCandidatesRaw?.value || '80', 10),
      max_hops: parseInt(cfgMaxHops?.value || '3', 10),
      beam_k: parseInt(cfgBeamK?.value || '20', 10),
      edge_top_m: parseInt(cfgEdgeTopM?.value || '2', 10),
      probe_amount: Number(cfgProbeAmount?.value || 1),
      report_currency: String(cfgReportCurrency?.value || 'USDC').trim().toUpperCase(),
      min_profit_pct: Number(cfgMinPct.value || 0),
      min_profit_abs: Number(cfgMinAbs.value || 0),
      slippage_bps: parseInt(cfgSlip.value || '0', 10),
      mev_buffer_bps: parseInt(cfgMev.value || '0', 10),
      max_gas_gwei: (cfgGas.value === '' ? null : Number(cfgGas.value)),
      concurrency: parseInt(cfgConc.value || '10', 10),
      scan_source: String(cfgScanSource?.value || 'block'),
      block_budget_s: Number(cfgBudget.value || 10),
      scan_mode: String(cfgMode.value || 'auto'),

      amount_presets: (cfgAmts.value || '').trim(),

      stage1_amount: Number(cfgS1Amt.value || 1),
      stage2_top_k: parseInt(cfgTopK.value || '30', 10),
      stage2_amount_min: (range.min == null || !isFinite(range.min)) ? null : range.min,
      stage2_amount_max: (range.max == null || !isFinite(range.max)) ? null : range.max,
      stage2_max_evals: parseInt(cfgEvals.value || '6', 10),

      rpc_timeout_stage1_s: Number(cfgT1.value || 3),
      rpc_timeout_stage2_s: Number(cfgT2.value || 4),
      v2_min_reserve_ratio: Number(cfgV2Ratio.value || 0),
      v2_max_price_impact_bps: Number(cfgV2Impact.value || 0),
      sim_profile: String(cfgSimProfile?.value || '').trim(),
      debug_funnel: !!cfgDebugFunnel?.checked,
      gas_off: !!cfgGasOff?.checked,
      fixed_gas_units: Number(cfgFixedGas?.value || 0),
      sim_backend: String(cfgSimBackend?.value || 'quote').trim(),
      execution_mode: String(cfgExecMode?.value || 'off').trim(),
      arb_executor_address: String(cfgArbExecutorAddr?.value || '').trim(),
      arb_executor_owner: String(cfgArbExecutorOwner?.value || '').trim(),

      mempool_enabled: String(cfgScanSource?.value || 'block') !== 'block',
      mempool_ws_urls: String(cfgMempoolWs?.value || '').trim(),
      mempool_watch_mode: String(cfgMempoolWatchMode?.value || 'strict').trim(),
      mempool_watched_router_sets: String(cfgMempoolWatchPreset?.value || 'core').trim(),
      mempool_min_value_usd: Number(cfgMempoolMinUsd?.value || 25),
      mempool_allow_unknown_tokens: !!cfgMempoolAllowUnknown?.checked,
      mempool_raw_min_enabled: !!cfgMempoolRawMinEnabled?.checked,
      mempool_max_inflight_tx: parseInt(cfgMempoolInflight?.value || '200', 10),
      mempool_fetch_tx_concurrency: parseInt(cfgMempoolFetchConc?.value || '20', 10),
      mempool_dedup_ttl_s: parseInt(cfgMempoolDedup?.value || '120', 10),
      mempool_trigger_scan_budget_s: Number(cfgMempoolBudget?.value || 1.5),
    };
  }

  function fillForm(cfg){
    if (cfgRpcUrls) {
      const ru = cfg.rpc_urls;
      cfgRpcUrls.value = Array.isArray(ru) ? ru.join('\n') : String(ru || '');
    }
    if (cfgDexes) {
      const dx = cfg.dexes;
      cfgDexes.value = formatCsvList(dx) || String(dx || '');
    }
    if (cfgEnableMultidex) cfgEnableMultidex.checked = !!cfg.enable_multidex;
    if (cfgTriggerPreferCrossDex) cfgTriggerPreferCrossDex.checked = !!cfg.trigger_prefer_cross_dex;
    if (cfgTriggerRequireCrossDex) cfgTriggerRequireCrossDex.checked = !!cfg.trigger_require_cross_dex;
    if (cfgTriggerCrossDexFallback) cfgTriggerCrossDexFallback.checked = !!cfg.trigger_cross_dex_fallback;
    if (cfgTriggerRequire3Hops) cfgTriggerRequire3Hops.checked = !!cfg.trigger_require_three_hops;
    if (cfgTriggerBaseFallback) cfgTriggerBaseFallback.checked = !!cfg.trigger_base_fallback_enabled;
    if (cfgTriggerAllowTwoHop) cfgTriggerAllowTwoHop.checked = !!cfg.trigger_allow_two_hop_fallback;
    if (cfgTriggerConnectors) cfgTriggerConnectors.value = formatCsvList(cfg.trigger_connectors) || String(cfg.trigger_connectors || '');
    if (cfgTriggerMaxCandidatesRaw) cfgTriggerMaxCandidatesRaw.value = String(cfg.trigger_max_candidates_raw ?? 80);
    if (cfgMaxHops) cfgMaxHops.value = String(cfg.max_hops ?? 3);
    if (cfgBeamK) cfgBeamK.value = String(cfg.beam_k ?? 20);
    if (cfgEdgeTopM) cfgEdgeTopM.value = String(cfg.edge_top_m ?? 2);
    if (cfgProbeAmount) cfgProbeAmount.value = String(cfg.probe_amount ?? 1);
    if (cfgReportCurrency) {
      const rc = String(cfg.report_currency || 'USDC').trim().toUpperCase();
      cfgReportCurrency.value = (rc === 'USDT') ? 'USDT' : 'USDC';
      profitCurrency = cfgReportCurrency.value;
    }
    cfgMinPct.value = String(cfg.min_profit_pct ?? 0.05);
    cfgMinAbs.value = String(cfg.min_profit_abs ?? 0.05);
    cfgSlip.value = String(cfg.slippage_bps ?? 8);
    cfgMev.value = String(cfg.mev_buffer_bps ?? 5);
    cfgGas.value = (cfg.max_gas_gwei == null ? '' : String(cfg.max_gas_gwei));
    cfgConc.value = String(cfg.concurrency ?? 10);
    if (cfgScanSource) {
      const src = String(cfg.scan_source || 'block').trim().toLowerCase();
      cfgScanSource.value = ['block','mempool','hybrid'].includes(src) ? src : 'block';
    }
    cfgMode.value = String(cfg.scan_mode ?? 'auto');
    cfgBudget.value = String(cfg.block_budget_s ?? 10);
    const ap = cfg.amount_presets;
    cfgAmts.value = formatCsvList(ap) || String(ap ?? '1,3,10');

    cfgS1Amt.value = String(cfg.stage1_amount ?? 1);
    cfgTopK.value = String(cfg.stage2_top_k ?? 30);
    const rmin = cfg.stage2_amount_min ?? 0.5;
    const rmax = cfg.stage2_amount_max ?? 50;
    cfgRange.value = formatRangeValue(rmin, rmax);
    cfgEvals.value = String(cfg.stage2_max_evals ?? 6);
    cfgT1.value = String(cfg.rpc_timeout_stage1_s ?? 3);
    cfgT2.value = String(cfg.rpc_timeout_stage2_s ?? 4);
    cfgV2Ratio.value = String(cfg.v2_min_reserve_ratio ?? 20);
    cfgV2Impact.value = String(cfg.v2_max_price_impact_bps ?? 300);
    if (cfgSimProfile) cfgSimProfile.value = String(cfg.sim_profile || '');
    if (cfgDebugFunnel) cfgDebugFunnel.checked = !!cfg.debug_funnel;
    if (cfgGasOff) cfgGasOff.checked = !!cfg.gas_off;
    if (cfgFixedGas) cfgFixedGas.value = String(cfg.fixed_gas_units ?? 0);
    if (cfgSimBackend) cfgSimBackend.value = String(cfg.sim_backend || 'quote');
    if (cfgExecMode) cfgExecMode.value = String(cfg.execution_mode || 'off');
    if (cfgArbExecutorAddr) cfgArbExecutorAddr.value = String(cfg.arb_executor_address || '');
    if (cfgArbExecutorOwner) cfgArbExecutorOwner.value = String(cfg.arb_executor_owner || '');
    if (cfgMempoolWs) {
      const ws = cfg.mempool_ws_urls;
      cfgMempoolWs.value = Array.isArray(ws) ? ws.join('\n') : String(ws || '');
    }
    if (cfgMempoolMinUsd) cfgMempoolMinUsd.value = String(cfg.mempool_min_value_usd ?? 25);
    if (cfgMempoolAllowUnknown) cfgMempoolAllowUnknown.checked = !!cfg.mempool_allow_unknown_tokens;
    if (cfgMempoolRawMinEnabled) cfgMempoolRawMinEnabled.checked = !!cfg.mempool_raw_min_enabled;
    if (cfgMempoolInflight) cfgMempoolInflight.value = String(cfg.mempool_max_inflight_tx ?? 200);
    if (cfgMempoolFetchConc) cfgMempoolFetchConc.value = String(cfg.mempool_fetch_tx_concurrency ?? 20);
    if (cfgMempoolDedup) cfgMempoolDedup.value = String(cfg.mempool_dedup_ttl_s ?? 120);
    if (cfgMempoolBudget) cfgMempoolBudget.value = String(cfg.mempool_trigger_scan_budget_s ?? 1.5);
    if (cfgMempoolWatchPreset) {
      const preset = String(cfg.mempool_watched_router_sets || 'core').toLowerCase();
      cfgMempoolWatchPreset.value = (preset === 'extended') ? 'extended' : 'core';
    }
    if (cfgMempoolWatchMode) {
      const mode = String(cfg.mempool_watch_mode || 'strict').toLowerCase();
      cfgMempoolWatchMode.value = (mode === 'routers_only') ? 'routers_only' : 'strict';
    }
    updateHeaderBadges();
    updateCrossDexGuard();
    updateStats();
    drawChart();
    rebuildProfitTable();
    renderWatchedRouters();
    schedulePersist();
  }

  function initColumnResizers(){
    if (!dealsTable) return;
    const minW = { time: 60, route: 180, spent: 90, roi: 70, profit: 90 };
    const handles = dealsTable.querySelectorAll('.colResizer');
    handles.forEach((handle) => {
      handle.addEventListener('dblclick', () => {
        const col = handle.dataset.col;
        if (!col) return;
        dealsTable.style.removeProperty(`--col-${col}`);
      });
      handle.addEventListener('pointerdown', (e) => {
        const col = handle.dataset.col;
        if (!col) return;
        const colEl = dealsTable.querySelector(`.col-${col}`);
        const startX = e.clientX;
        const startWidth = colEl ? colEl.getBoundingClientRect().width : 100;

        const onMove = (ev) => {
          const next = Math.max(minW[col] || 80, startWidth + (ev.clientX - startX));
          dealsTable.style.setProperty(`--col-${col}`, `${Math.round(next)}px`);
        };
        const onUp = () => {
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
        };
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
        e.preventDefault();
      });
    });
  }

  // Settings buttons
  saveCfgBtn.addEventListener('click', async () => {
    setNotice('status', 'Saving config...');
    const out = await saveConfig(cfgFromForm());
    if (out.ok) setNotice('status', 'Config saved');
    else setNotice('warn', 'Config save failed: ' + (out.error || 'unknown'));
  });

  applyCfgBtn.addEventListener('click', async () => {
    setNotice('status', 'Applying config (restart)...');
    const saved = await saveConfig(cfgFromForm());
    if (!saved.ok){
      setNotice('warn', 'Config save failed: ' + (saved.error || 'unknown'));
      return;
    }
    // Proper restart waits for the old bot process to fully exit before starting,
    // otherwise /start may return alreadyRunning and the new config won't apply.
    const started = await post('/restart');
    if (started.ok) setNotice('status', 'Restarted with new config');
    else setNotice('warn', 'Restart failed: ' + (started.error || 'unknown'));
  });
  if (applyCfgBtnTop) {
    applyCfgBtnTop.addEventListener('click', () => {
      applyCfgBtn.click();
    });
  }

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    setNotice('status', 'Starting...');
    const out = await post('/start');
    if (!out.ok){
      setNotice('warn', 'Failed to start: ' + (out.error || 'unknown'));
      setRunning(false);
    }
  });

  stopBtn.addEventListener('click', async () => {
    stopBtn.disabled = true;
    setNotice('status', 'Stopping...');
    const out = await post('/stop');
    if (!out.ok){
      setNotice('warn', 'Failed to stop: ' + (out.error || 'unknown'));
    }
    // actual state will be updated by WS status message
  });

  if (cfgPreset) {
    cfgPreset.addEventListener('change', updatePresetDesc);
  }
  if (cfgScanSource) {
    cfgScanSource.addEventListener('change', updateHeaderBadges);
  }
  if (cfgMempoolWatchPreset) {
    cfgMempoolWatchPreset.addEventListener('change', renderWatchedRouters);
  }
  if (cfgTriggerRequireCrossDex) {
    cfgTriggerRequireCrossDex.addEventListener('change', updateCrossDexGuard);
  }
  if (cfgTriggerPreferCrossDex) {
    cfgTriggerPreferCrossDex.addEventListener('change', updateCrossDexGuard);
  }
  if (recDebugBtn) {
    recDebugBtn.addEventListener('click', () => applyQuickProfile('debug'));
  }
  if (recCrossDexBtn) {
    recCrossDexBtn.addEventListener('click', () => applyQuickProfile('cross_dex'));
  }
  if (recStrictBtn) {
    recStrictBtn.addEventListener('click', () => applyQuickProfile('strict'));
  }
  if (applyPresetBtn) {
    applyPresetBtn.addEventListener('click', applyPresetSelection);
  }
  if (copyDebugBtn) {
    copyDebugBtn.addEventListener('click', async () => {
      const lastSwap = mempoolSwaps[mempoolSwaps.length - 1] || null;
      const lastTrigger = mempoolTriggerScans[mempoolTriggerScans.length - 1] || null;
      const lines = [
        `last_block=${lastBlockEl ? lastBlockEl.textContent : '—'}`,
        `mempool_ws=${mempoolStatus && mempoolStatus.ws_connected ? 'connected' : 'offline'}`,
        `hash_rate=${mempoolStatus ? Number(mempoolStatus.tx_hash_rate || 0).toFixed(2) : '0'}`,
        `fetch_success=${mempoolStatus ? (Number(mempoolStatus.tx_fetch_success_rate || 0) * 100).toFixed(1) + '%' : '0%'}`,
        `last_swap=${lastSwap ? (lastSwap.kind + ' ' + (lastSwap.token_in || '?') + '->' + (lastSwap.token_out || '?')) : '—'}`,
        `last_trigger=${lastTrigger ? (lastTrigger.outcome + ' net=' + Number(lastTrigger.best_net || 0).toFixed(4)) : '—'}`,
      ];
      const text = lines.join('\n');
      try {
        await navigator.clipboard.writeText(text);
        setNotice('status', 'Debug summary copied');
      } catch {
        setNotice('warn', 'Copy failed');
      }
    });
  }
  if (copyPackBtn) {
    copyPackBtn.addEventListener('click', async () => {
      try {
        const resp = await fetch('/api/assistant_pack');
        const data = await resp.json();
        if (!data || !data.ok || !data.pack) {
          setNotice('warn', 'Assistant pack unavailable');
          return;
        }
        const text = JSON.stringify(data.pack, null, 2);
        await navigator.clipboard.writeText(text);
        setNotice('status', 'Assistant pack copied');
      } catch {
        setNotice('warn', 'Copy failed');
      }
    });
  }

  // -----------------------------
  // Init
  const restored = restoreState();
  if (!restored) drawChart();
  initColumnResizers();
  initCollapsibles();
  initSettingsSearch();
  updateHeaderBadges();
  updateCrossDexGuard();
  // Load settings once on page init
  getConfig().then((c)=>{
    if (c && c.ok) fillForm(c.config || {});
  }).catch(()=>{});
  loadPresetIndex();
  refreshMempoolPanels();
  setInterval(refreshMempoolPanels, 2500);

  fetchServerState();
  connectWS();
</script>
</body>
</html>
